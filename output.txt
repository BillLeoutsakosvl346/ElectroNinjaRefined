Project Description:
====================
This project is an AI-driven electrical engineering assistant designed to autonomously generate, evaluate, and refine electrical circuits. The workflow begins when a user provides a high-level prompt describing a desired circuit. A language model (LLM) processes the prompt and generates a corresponding LTSpice .asc file, which represents the circuit schematic. This file is then fed into LTSpice, where the circuit is visualized and simulated. Once the simulation is complete, the circuit is extracted as a PDF, which is subsequently converted into a .png image. This image is passed into a vision model that analyzes the circuit for correctness, compliance with design specifications, and potential errors. The model's evaluation serves as feedback, guiding the refinement process by informing the LLM of necessary modifications to the .asc file, such as correcting wiring errors, improving component placement, or optimizing circuit performance. This loop—comprising prompt processing, circuit generation, simulation, evaluation, and refinement—continues iteratively until a fully functional circuit is achieved. The project integrates multiple components, including LLM-based text generation, vector databases for knowledge retrieval, LTSpice for simulation, computer vision for schematic analysis, and a feedback-driven improvement loop to enhance circuit accuracy over time. The existing implementation is structured into a monolithic set of scripts but can be improved through modularization, ensuring better debugging, maintainability, and scalability. Refinements should focus on breaking down tasks into dedicated modules, such as separate handling for file management, circuit generation, vision processing, simulation control, and feedback mechanisms, ultimately making the agent more robust and efficient.

Directory Tree Structure (from 'tree /F'):
========================================
Folder PATH listing for volume OS
Volume serial number is 76F9-9654
C:.
ª   .env
ª   .gitignore
ª   get_files.py
ª   ingest_examples.py
ª   main.py
ª   output.txt
ª   requirements.txt
ª   __init__.py
ª   
+---data
ª   +---examples_asc
ª   ª       2paraller.asc
ª   ª       2paraller.log
ª   ª       ac_coupling.asc
ª   ª       bridge_rectifier_with_cap_filter.asc
ª   ª       capacitive_voltage_divider.asc
ª   ª       diode_peak_detector.asc
ª   ª       half_wave_rectifier.asc
ª   ª       ladder_resistor_network.asc
ª   ª       led_current_limiter.asc
ª   ª       metadata.json
ª   ª       mixed_series_parallel.asc
ª   ª       parallel_rlc.asc
ª   ª       rc_differentiator.asc
ª   ª       rc_filter.asc
ª   ª       rc_highpass.asc
ª   ª       rc_integrator.asc
ª   ª       rlc_bandpass.asc
ª   ª       rlc_bandstop.asc
ª   ª       rl_highpass.asc
ª   ª       rl_lowpass.asc
ª   ª       series_resistors.asc
ª   ª       series_rlc.asc
ª   ª       simple_ac_capacitor.asc
ª   ª       simple_ac_inductor.asc
ª   ª       simple_dc_resistor.asc
ª   ª       voltage_divider.asc
ª   ª       voltage_doubler.asc
ª   ª       zener_regulator.asc
ª   ª       
ª   +---output
ª   +---vector_db
ª           faiss_index.bin
ª           metadata_list.pkl
ª           
+---electroninja
ª   ª   __init__.py
ª   ª   
ª   +---config
ª   ª   ª   logging_config.py
ª   ª   ª   settings.py
ª   ª   ª   __init__.py
ª   ª   ª   
ª   ª   +---__pycache__
ª   ª           logging_config.cpython-312.pyc
ª   ª           settings.cpython-312.pyc
ª   ª           __init__.cpython-312.pyc
ª   ª           
ª   +---core
ª   ª   ª   circuit_processor.py
ª   ª   ª   __init__.py
ª   ª   ª   
ª   ª   +---feedback
ª   ª   ª   ª   evaluator.py
ª   ª   ª   ª   loop_manager.py
ª   ª   ª   ª   state_tracker.py
ª   ª   ª   ª   __init__.py
ª   ª   ª   ª   
ª   ª   ª   +---__pycache__
ª   ª   ª           evaluator.cpython-312.pyc
ª   ª   ª           loop_manager.cpython-312.pyc
ª   ª   ª           state_tracker.cpython-312.pyc
ª   ª   ª           __init__.cpython-312.pyc
ª   ª   ª           
ª   ª   +---ltspice
ª   ª   ª   ª   interface.py
ª   ª   ª   ª   __init__.py
ª   ª   ª   ª   
ª   ª   ª   +---__pycache__
ª   ª   ª           file_manager.cpython-312.pyc
ª   ª   ª           image_extractor.cpython-312.pyc
ª   ª   ª           interface.cpython-312.pyc
ª   ª   ª           __init__.cpython-312.pyc
ª   ª   ª           
ª   ª   +---__pycache__
ª   ª           circuit_processor.cpython-312.pyc
ª   ª           __init__.cpython-312.pyc
ª   ª           
ª   +---llm
ª   ª   ª   vector_store.py
ª   ª   ª   vision_analyser.py
ª   ª   ª   __init__.py
ª   ª   ª   
ª   ª   +---prompts
ª   ª   ª   ª   chat_prompts.py
ª   ª   ª   ª   circuit_prompts.py
ª   ª   ª   ª   __init__.py
ª   ª   ª   ª   
ª   ª   ª   +---__pycache__
ª   ª   ª           chat_prompts.cpython-312.pyc
ª   ª   ª           circuit_prompts.cpython-312.pyc
ª   ª   ª           __init__.cpython-312.pyc
ª   ª   ª           
ª   ª   +---providers
ª   ª   ª   ª   base.py
ª   ª   ª   ª   openai.py
ª   ª   ª   ª   __init__.py
ª   ª   ª   ª   
ª   ª   ª   +---__pycache__
ª   ª   ª           base.cpython-312.pyc
ª   ª   ª           openai.cpython-312.pyc
ª   ª   ª           __init__.cpython-312.pyc
ª   ª   ª           
ª   ª   +---__pycache__
ª   ª           vector_store.cpython-312.pyc
ª   ª           vision_analyser.cpython-312.pyc
ª   ª           __init__.cpython-312.pyc
ª   ª           
ª   +---ui
ª   ª   ª   main_window.py
ª   ª   ª   signals.py
ª   ª   ª   styles.py
ª   ª   ª   __init__.py
ª   ª   ª   
ª   ª   +---components
ª   ª   ª   ª   chat_bubble.py
ª   ª   ª   ª   chat_input.py
ª   ª   ª   ª   chat_panel.py
ª   ª   ª   ª   top_bar.py
ª   ª   ª   ª   __init__.py
ª   ª   ª   ª   
ª   ª   ª   +---__pycache__
ª   ª   ª           chat_bubble.cpython-312.pyc
ª   ª   ª           chat_input.cpython-312.pyc
ª   ª   ª           chat_panel.cpython-312.pyc
ª   ª   ª           top_bar.cpython-312.pyc
ª   ª   ª           __init__.cpython-312.pyc
ª   ª   ª           
ª   ª   +---panels
ª   ª   ª   ª   left_panel.py
ª   ª   ª   ª   middle_panel.py
ª   ª   ª   ª   right_panel.py
ª   ª   ª   ª   __init__.py
ª   ª   ª   ª   
ª   ª   ª   +---__pycache__
ª   ª   ª           left_panel.cpython-312.pyc
ª   ª   ª           middle_panel.cpython-312.pyc
ª   ª   ª           right_panel.cpython-312.pyc
ª   ª   ª           __init__.cpython-312.pyc
ª   ª   ª           
ª   ª   +---__pycache__
ª   ª           main_window.cpython-312.pyc
ª   ª           styles.cpython-312.pyc
ª   ª           __init__.cpython-312.pyc
ª   ª           
ª   +---utils
ª   ª   ª   async_workers.py
ª   ª   ª   error_handler.py
ª   ª   ª   file_operations.py
ª   ª   ª   __init__.py
ª   ª   ª   
ª   ª   +---__pycache__
ª   ª           async_workers.cpython-312.pyc
ª   ª           error_handler.cpython-312.pyc
ª   ª           file_operations.cpython-312.pyc
ª   ª           __init__.cpython-312.pyc
ª   ª           
ª   +---__pycache__
ª           __init__.cpython-312.pyc
ª           
+---logs
+---tests
        test_asc_generation_rag.py
        test_asc_refinement.py
        test_circuit_chat_response.py
        test_circuit_evaluation.py
        test_full_pipeline.py
        test_ltspice_processing.py
        test_vision_analysis.py
        test_vision_feedback_response.py
        


Detailed File Contents:
==============================

File: .\.gitignore
------------------
# Environment variables
.env
.env.*

# Python bytecode and cache
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
.pytest_cache/
.coverage
htmlcov/
.tox/

# Distribution / packaging
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Jupyter notebooks
.ipynb_checkpoints

# Virtual environments
venv/
env/
ENV/
.venv/
.python-version

# IDE configurations
.idea/
.vscode/
*.swp
*.swo
*~
.spyderproject
.spyproject
.ropeproject

# Log files
logs/
*.log

# Project specific files/directories
data/output/
faiss_index.bin
metadata_list.pkl
output-*/

# LTSpice files in output directories
*.raw
*.log
*.net

# OS specific files
.DS_Store
Thumbs.db
desktop.ini

# Temporary files
*.tmp
*.bak
temp/

File: .\get_files.py
--------------------
import os
import subprocess

# Project description to be added at the top of the output file.
project_description = """
This project is an AI-driven electrical engineering assistant designed to autonomously generate, evaluate, and refine electrical circuits. The workflow begins when a user provides a high-level prompt describing a desired circuit. A language model (LLM) processes the prompt and generates a corresponding LTSpice .asc file, which represents the circuit schematic. This file is then fed into LTSpice, where the circuit is visualized and simulated. Once the simulation is complete, the circuit is extracted as a PDF, which is subsequently converted into a .png image. This image is passed into a vision model that analyzes the circuit for correctness, compliance with design specifications, and potential errors. The model's evaluation serves as feedback, guiding the refinement process by informing the LLM of necessary modifications to the .asc file, such as correcting wiring errors, improving component placement, or optimizing circuit performance. This loop—comprising prompt processing, circuit generation, simulation, evaluation, and refinement—continues iteratively until a fully functional circuit is achieved. The project integrates multiple components, including LLM-based text generation, vector databases for knowledge retrieval, LTSpice for simulation, computer vision for schematic analysis, and a feedback-driven improvement loop to enhance circuit accuracy over time. The existing implementation is structured into a monolithic set of scripts but can be improved through modularization, ensuring better debugging, maintainability, and scalability. Refinements should focus on breaking down tasks into dedicated modules, such as separate handling for file management, circuit generation, vision processing, simulation control, and feedback mechanisms, ultimately making the agent more robust and efficient.
"""

def is_meaningful_file(file_name):
    """
    Check if a file is meaningful based on its extension or specific filename.
    Adjust allowed_extensions and allowed_no_extension as needed.
    """
    allowed_extensions = {".py", ".txt", ".json", ".env", ".ini", ".md", ".cfg", ".pyw"}
    allowed_no_extension = {"gitignore", ".gitignore"}
    name, ext = os.path.splitext(file_name)
    if ext:
        return ext.lower() in allowed_extensions
    else:
        return file_name in allowed_no_extension

def write_file_contents(output_file, base_path, ignore_dirs=None):
    """
    Walk through the directory and write file titles and content
    to the provided output_file handle, ignoring specified directories.
    """
    if ignore_dirs is None:
        ignore_dirs = []
    for root, dirs, files in os.walk(base_path):
        # Remove directories we want to ignore.
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        for file in files:
            if not is_meaningful_file(file):
                continue  # Skip files that are not considered meaningful.
            file_path = os.path.join(root, file)
            header = f"\nFile: {file_path}\n{'-' * (len(file_path) + 6)}\n"
            output_file.write(header)
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    output_file.write(f.read() + "\n")
            except Exception as e:
                output_file.write(f"Error reading {file_path}: {e}\n")

if __name__ == "__main__":
    base_directory = "."
    ignore_dirs = ["data", "logs", "__pycache__"]
    output_filename = "output.txt"

    with open(output_filename, "w", encoding="utf-8") as out:
        # Write the project description at the top.
        out.write("Project Description:\n")
        out.write("=" * 20 + "\n")
        out.write(project_description.strip() + "\n\n")

        # Write the directory tree structure.
        out.write("Directory Tree Structure (from 'tree /F'):\n")
        out.write("=" * 40 + "\n")
        try:
            # Execute the 'tree /F' command (Windows only).
            tree_output = subprocess.check_output("tree /F", stderr=subprocess.STDOUT, shell=True)
            # Decode using the OEM code page (commonly cp437 on Windows).
            tree_output = tree_output.decode("cp437")
            out.write(tree_output + "\n")
        except Exception as e:
            out.write(f"Error retrieving tree structure: {e}\n")

        # Write the detailed file titles and contents.
        out.write("\nDetailed File Contents:\n")
        out.write("=" * 30 + "\n")
        write_file_contents(out, base_directory, ignore_dirs)
    
    print(f"Output successfully written to {output_filename}")


File: .\ingest_examples.py
--------------------------
#!/usr/bin/env python3
"""
Ingest examples from metadata.json into the FAISS vector store
"""

import os
import json
import sys
import logging
from dotenv import load_dotenv

# Setup path to allow imports from the main project
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Import the vector store
from electroninja.config.settings import Config
from electroninja.llm.vector_store import VectorStore
from electroninja.config import logger

# Load environment variables (needed for OpenAI API key)
load_dotenv()

def extract_clean_asc_code(asc_code):
    """
    Extract only the pure ASC code starting from 'Version 4'
    This ensures we don't include descriptions in the ASC code examples
    """
    if "Version 4" in asc_code:
        idx = asc_code.find("Version 4")
        return asc_code[idx:].strip()
    return asc_code.strip()

def ingest_examples():
    """
    Ingest examples from metadata.json into the vector database
    """
    # Initialize the vector store with config
    config = Config()
    vector_store = VectorStore(config)
    
    # Path to metadata.json
    metadata_path = os.path.join(config.EXAMPLES_DIR, "metadata.json")
    
    # Check if metadata file exists
    if not os.path.exists(metadata_path):
        logger.error(f"Metadata file not found: {metadata_path}")
        return False
    
    # Read metadata.json
    logger.info(f"Reading examples from {metadata_path}")
    with open(metadata_path, "r", encoding="utf-8") as f:
        examples = json.load(f)
    
    logger.info(f"Found {len(examples)} examples in metadata.json")
    
    # Process each example
    successful = 0
    for i, example in enumerate(examples, 1):
        asc_path = example.get("asc_path")
        description = example.get("description", "No description")
        
        # Validate path
        if not asc_path:
            logger.warning(f"Example {i}: Missing asc_path")
            continue
            
        # Convert relative path if needed
        if not os.path.isabs(asc_path):
            asc_path = os.path.join(config.BASE_DIR, asc_path)
        
        # Check if file exists
        if not os.path.exists(asc_path):
            logger.warning(f"Example {i}: File not found: {asc_path}")
            continue
        
        # Read ASC file
        try:
            with open(asc_path, "r", encoding="utf-8") as asc_file:
                full_asc_code = asc_file.read().strip()
            
            # Extract only the pure ASC code starting from "Version 4"
            clean_asc_code = extract_clean_asc_code(full_asc_code)
            
            # Store the embeddings for the combined text, but keep ASC code separate from description
            # in the storage to avoid duplication in prompts
            combined_text = f"{description}\n\n{clean_asc_code}"
            
            # Add to vector store with properly separated fields
            if vector_store.add_document(combined_text, metadata={
                "asc_path": asc_path, 
                "description": description, 
                "pure_asc_code": clean_asc_code
            }):
                successful += 1
                logger.info(f"Example {i}: Added {os.path.basename(asc_path)}")
            else:
                logger.warning(f"Example {i}: Failed to add {os.path.basename(asc_path)}")
        
        except Exception as e:
            logger.error(f"Example {i}: Error processing {os.path.basename(asc_path)}: {str(e)}")
    
    # Save the index
    if successful > 0:
        if vector_store.save():
            logger.info(f"Successfully ingested {successful} examples out of {len(examples)}")
            logger.info(f"Index saved to {config.VECTOR_DB_INDEX}")
            logger.info(f"Metadata saved to {config.VECTOR_DB_METADATA}")
            return True
        else:
            logger.error("Failed to save index")
            return False
    else:
        logger.error("No examples were successfully ingested")
        return False

if __name__ == "__main__":
    # Configure logging for command-line usage
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Run ingestion
    print("Starting ingestion of examples...")
    result = ingest_examples()
    
    if result:
        print("\nIngestion completed successfully!")
        print(f"Check the logs for details.")
    else:
        print("\nIngestion failed or completed with errors.")
        print("Check the logs for details.")

File: .\main.py
---------------
#!/usr/bin/env python3
"""
ElectroNinja - AI Electrical Engineer

An AI-powered application that helps design electronic circuits
using LTSpice and AI models for feedback and refinement.
"""

import sys
import logging
from PyQt5.QtWidgets import QApplication
from PyQt5.QtGui import QFont

# Initialize configuration and logging
from electroninja.config import logger
from electroninja.ui.main_window import MainWindow

def main():
    """Main entry point for the application"""
    # Log application startup
    logger.info("ElectroNinja starting...")
    
    # Create Qt application
    app = QApplication(sys.argv)
    
    # Set default font
    default_font = QFont("Segoe UI", 10)
    app.setFont(default_font)
    
    # Create and show main window
    window = MainWindow()
    window.show()
    
    # Log application ready
    logger.info("ElectroNinja UI initialized and ready")
    
    # Start event loop
    return app.exec_()

if __name__ == "__main__":
    sys.exit(main())

File: .\output.txt
------------------
Project Description:
====================
This project is an AI-driven electrical engineering assistant designed to autonomously generate, evaluate, and refine electrical circuits. The workflow begins when a user provides a high-level prompt describing a desired circuit. A language model (LLM) processes the prompt and generates a corresponding LTSpice .asc file, which represents the circuit schematic. This file is then fed into LTSpice, where the circuit is visualized and simulated. Once the simulation is complete, the circuit is extracted as a PDF, which is subsequently converted into a .png image. This image is passed into a vision model that analyzes the circuit for correctness, compliance with design specifications, and potential errors. The model's evaluation serves as feedback, guiding the refinement process by informing the LLM of necessary modifications to the .asc file, such as correcting wiring errors, improving component placement, or optimizing circuit performance. This loop—comprising prompt processing, circuit generation, simulation, evaluation, and refinement—continues iteratively until a fully functional circuit is achieved. The project integrates multiple components, including LLM-based text generation, vector databases for knowledge retrieval, LTSpice for simulation, computer vision for schematic analysis, and a feedback-driven improvement loop to enhance circuit accuracy over time. The existing implementation is structured into a monolithic set of scripts but can be improved through modularization, ensuring better debugging, maintainability, and scalability. Refinements should focus on breaking down tasks into dedicated modules, such as separate handling for file management, circuit generation, vision processing, simulation control, and feedback mechanisms, ultimately making the agent more robust and efficient.

Directory Tree Structure (from 'tree /F'):
========================================
Folder PATH listing for volume OS

Volume serial number is 76F9-9654

C:.

ª   .env

ª   .gitignore

ª   get_files.py

ª   ingest_examples.py

ª   main.py

ª   output.txt

ª   requirements.txt

ª   __init__.py

ª   

+---data

ª   +---examples_asc

ª   ª       2paraller.asc

ª   ª       2paraller.log

ª   ª       ac_coupling.asc

ª   ª       bridge_rectifier_with_cap_filter.asc

ª   ª       capacitive_voltage_divider.asc

ª   ª       diode_peak_detector.asc

ª   ª       half_wave_rectifier.asc

ª   ª       ladder_resistor_network.asc

ª   ª       led_current_limiter.asc

ª   ª       metadata.json

ª   ª       mixed_series_parallel.asc

ª   ª       parallel_rlc.asc

ª   ª       rc_differentiator.asc

ª   ª       rc_filter.asc

ª   ª       rc_highpass.asc

ª   ª       rc_integrator.asc

ª   ª       rlc_bandpass.asc

ª   ª       rlc_bandstop.asc

ª   ª       rl_highpass.asc

ª   ª       rl_lowpass.asc

ª   ª       series_resistors.asc

ª   ª       series_rlc.asc

ª   ª       simple_ac_capacitor.asc

ª   ª       simple_ac_inductor.asc

ª   ª       simple_dc_resistor.asc

ª   ª       voltage_divider.asc

ª   ª       voltage_doubler.asc

ª   ª       zener_regulator.asc

ª   ª       

ª   +---output

ª   +---vector_db

ª           faiss_index.bin

ª           metadata_list.pkl

ª           

+---electroninja

ª   ª   __init__.py

ª   ª   

ª   +---config

ª   ª   ª   logging_config.py

ª   ª   ª   settings.py

ª   ª   ª   __init__.py

ª   ª   ª   

ª   ª   +---__pycache__

ª   ª           logging_config.cpython-312.pyc

ª   ª           settings.cpython-312.pyc

ª   ª           __init__.cpython-312.pyc

ª   ª           

ª   +---core

ª   ª   ª   circuit_processor.py

ª   ª   ª   __init__.py

ª   ª   ª   

ª   ª   +---feedback

ª   ª   ª   ª   evaluator.py

ª   ª   ª   ª   loop_manager.py

ª   ª   ª   ª   state_tracker.py

ª   ª   ª   ª   __init__.py

ª   ª   ª   ª   

ª   ª   ª   +---__pycache__

ª   ª   ª           evaluator.cpython-312.pyc

ª   ª   ª           loop_manager.cpython-312.pyc

ª   ª   ª           state_tracker.cpython-312.pyc

ª   ª   ª           __init__.cpython-312.pyc

ª   ª   ª           

ª   ª   +---ltspice

ª   ª   ª   ª   interface.py

ª   ª   ª   ª   __init__.py

ª   ª   ª   ª   

ª   ª   ª   +---__pycache__

ª   ª   ª           file_manager.cpython-312.pyc

ª   ª   ª           image_extractor.cpython-312.pyc

ª   ª   ª           interface.cpython-312.pyc

ª   ª   ª           __init__.cpython-312.pyc

ª   ª   ª           

ª   ª   +---__pycache__

ª   ª           circuit_processor.cpython-312.pyc

ª   ª           __init__.cpython-312.pyc

ª   ª           

ª   +---llm

ª   ª   ª   vector_store.py

ª   ª   ª   vision_analyser.py

ª   ª   ª   __init__.py

ª   ª   ª   

ª   ª   +---prompts

ª   ª   ª   ª   chat_prompts.py

ª   ª   ª   ª   circuit_prompts.py

ª   ª   ª   ª   __init__.py

ª   ª   ª   ª   

ª   ª   ª   +---__pycache__

ª   ª   ª           chat_prompts.cpython-312.pyc

ª   ª   ª           circuit_prompts.cpython-312.pyc

ª   ª   ª           __init__.cpython-312.pyc

ª   ª   ª           

ª   ª   +---providers

ª   ª   ª   ª   base.py

ª   ª   ª   ª   openai.py

ª   ª   ª   ª   __init__.py

ª   ª   ª   ª   

ª   ª   ª   +---__pycache__

ª   ª   ª           base.cpython-312.pyc

ª   ª   ª           openai.cpython-312.pyc

ª   ª   ª           __init__.cpython-312.pyc

ª   ª   ª           

ª   ª   +---__pycache__

ª   ª           vector_store.cpython-312.pyc

ª   ª           vision_analyser.cpython-312.pyc

ª   ª           __init__.cpython-312.pyc

ª   ª           

ª   +---ui

ª   ª   ª   main_window.py

ª   ª   ª   signals.py

ª   ª   ª   styles.py

ª   ª   ª   __init__.py

ª   ª   ª   

ª   ª   +---components

ª   ª   ª   ª   chat_bubble.py

ª   ª   ª   ª   chat_input.py

ª   ª   ª   ª   chat_panel.py

ª   ª   ª   ª   top_bar.py

ª   ª   ª   ª   __init__.py

ª   ª   ª   ª   

ª   ª   ª   +---__pycache__

ª   ª   ª           chat_bubble.cpython-312.pyc

ª   ª   ª           chat_input.cpython-312.pyc

ª   ª   ª           chat_panel.cpython-312.pyc

ª   ª   ª           top_bar.cpython-312.pyc

ª   ª   ª           __init__.cpython-312.pyc

ª   ª   ª           

ª   ª   +---panels

ª   ª   ª   ª   left_panel.py

ª   ª   ª   ª   middle_panel.py

ª   ª   ª   ª   right_panel.py

ª   ª   ª   ª   __init__.py

ª   ª   ª   ª   

ª   ª   ª   +---__pycache__

ª   ª   ª           left_panel.cpython-312.pyc

ª   ª   ª           middle_panel.cpython-312.pyc

ª   ª   ª           right_panel.cpython-312.pyc

ª   ª   ª           __init__.cpython-312.pyc

ª   ª   ª           

ª   ª   +---__pycache__

ª   ª           main_window.cpython-312.pyc

ª   ª           styles.cpython-312.pyc

ª   ª           __init__.cpython-312.pyc

ª   ª           

ª   +---utils

ª   ª   ª   async_workers.py

ª   ª   ª   error_handler.py

ª   ª   ª   file_operations.py

ª   ª   ª   __init__.py

ª   ª   ª   

ª   ª   +---__pycache__

ª   ª           async_workers.cpython-312.pyc

ª   ª           error_handler.cpython-312.pyc

ª   ª           file_operations.cpython-312.pyc

ª   ª           __init__.cpython-312.pyc

ª   ª           

ª   +---__pycache__

ª           __init__.cpython-312.pyc

ª           

+---logs

+---tests

        test_asc_generation_rag.py

        test_asc_refinement.py

        test_circuit_chat_response.py

        test_circuit_evaluation.py

        test_full_pipeline.py

        test_ltspice_processing.py

        test_vision_analysis.py

        test_vision_feedback_response.py

        



Detailed File Contents:
==============================

File: .\.gitignore
------------------


File: .\requirements.txt
------------------------
openai==1.1.1
anthropic>=0.16.0
python-dotenv==1.0.0
PyQt5==5.15.9
PyQt5-Qt5==5.15.2
PyQt5-sip==12.12.1
faiss-cpu==1.7.4
numpy==1.24.3
Pillow==10.0.0
pyautogui==0.9.54
pygetwindow==0.0.9
pywinauto==0.6.8
psutil==5.9.5
pdf2image==1.16.3
PyMuPDF==1.23.3

File: .\__init__.py
-------------------
import os
import sys

# Add the project root directory to sys.path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if project_root not in sys.path:
    sys.path.insert(0, project_root)


File: .\electroninja\__init__.py
--------------------------------
"""
ElectroNinja - AI-powered electrical engineering assistant.

This package provides tools and utilities for LTSpice automation, 
circuit processing, and electrical engineering AI assistance.
"""

__version__ = '0.1.0'

File: .\electroninja\config\logging_config.py
---------------------------------------------
# logging_config.py


import logging
import os
from datetime import datetime

def setup_logging():
    """Configure logging for the application"""
    
    # Create logs directory if it doesn't exist
    logs_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "logs")
    os.makedirs(logs_dir, exist_ok=True)
    
    # Generate log file name with timestamp
    log_file = os.path.join(logs_dir, f"electroninja_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
    
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )
    
    # Create a logger
    logger = logging.getLogger('electroninja')
    logger.info("Logging initialized")
    
    return logger

File: .\electroninja\config\settings.py
---------------------------------------
# electroninja/config/settings.py
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class Config:
    """Centralized configuration for ElectroNinja"""
    
    # Application paths
    BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    OUTPUT_DIR = os.path.join(BASE_DIR, "data", "output")
    EXAMPLES_DIR = os.path.join(BASE_DIR, "data", "examples_asc")
    
    # LTSpice configuration
    LTSPICE_PATH = os.getenv("LTSPICE_PATH", 
                             r"C:\Users\vleou\AppData\Local\Programs\ADI\LTspice\LTspice.exe")
    
    # LLM configuration
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    ASC_MODEL = os.getenv("ASC_MODEL", "o3-mini")
    CHAT_MODEL = os.getenv("CHAT_MODEL", "gpt-4o-mini")
    
    # Vision configuration
    OPENAI_VISION_MODEL = os.getenv("OPENAI_VISION_MODEL", "gpt-4o")
    
    # Standard model name accessor for backwards compatibility
    @property
    def VISION_MODEL(self):
        """Returns the vision model name"""
        return self.OPENAI_VISION_MODEL
    
    EVALUATION_MODEL = os.getenv("EVALUATION_MODEL", "gpt-4o-mini")
    
    # Feedback loop configuration
    MAX_ITERATIONS = int(os.getenv("MAX_ITERATIONS", "5"))
    
    # Vector DB configuration
    VECTOR_DB_DIR = os.path.join(BASE_DIR, "data", "vector_db")
    VECTOR_DB_INDEX = os.path.join(VECTOR_DB_DIR, "faiss_index.bin")
    VECTOR_DB_METADATA = os.path.join(VECTOR_DB_DIR, "metadata_list.pkl")
    
    # Create necessary directories
    @classmethod
    def ensure_directories(cls):
        """Ensure all required directories exist"""
        os.makedirs(cls.OUTPUT_DIR, exist_ok=True)
        os.makedirs(cls.VECTOR_DB_DIR, exist_ok=True)

File: .\electroninja\config\__init__.py
---------------------------------------
from electroninja.config.logging_config import setup_logging
from electroninja.config.settings import Config

# Initialize logger
logger = setup_logging()

# Create necessary directories
Config.ensure_directories()

File: .\electroninja\core\circuit_processor.py
----------------------------------------------
import os
import logging
from electroninja.config.settings import Config
from electroninja.core.feedback.loop_manager import FeedbackLoopManager
from electroninja.core.ltspice.interface import LTSpiceInterface
from electroninja.llm.providers.openai import OpenAIProvider
from electroninja.llm.vector_store import VectorStore
from electroninja.utils.file_operations import save_file
from electroninja.utils.error_handler import LTSpiceError

logger = logging.getLogger('electroninja')

class CircuitProcessor:
    """Main entry point for circuit processing"""
    
    def __init__(self, config=None):
        self.config = config or Config()
        self.feedback_manager = FeedbackLoopManager(self.config)
        self.ltspice = LTSpiceInterface(self.config)
        self.llm_provider = OpenAIProvider(self.config)
        self.vector_store = VectorStore(self.config)
        
        # Load vector store
        self.vector_store.load()
        
    def process_circuit_request(self, request, status_callback=None):
        """
        Process a circuit request
        
        Args:
            request (str): User request
            status_callback (function): Callback for status updates
            
        Returns:
            dict: Result of processing
        """
        try:
            # Search for similar examples
            examples = self.vector_store.search(request)
            
            # Process the request
            result = self.feedback_manager.process_request(
                request,
                examples=examples,
                status_callback=status_callback
            )
            
            return result
            
        except Exception as e:
            logger.error(f"Circuit processing error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
            
    def is_circuit_request(self, message):
        """
        Check if a message is a circuit request
        
        Args:
            message (str): User message
            
        Returns:
            bool: True if it's a circuit request
        """
        keywords = ["circuit", "resistor", "capacitor", "oscillator", "filter", 
                    "transistor", "diode", "voltage", "current", "amplifier"]
        return any(kw in message.lower() for kw in keywords)
        
    def manual_circuit_processing(self, asc_code, status_callback=None, prompt_id=None, iteration=0):
        """
        Process a circuit manually
        
        Args:
            asc_code (str): ASC code
            status_callback (function): Callback for status updates
            prompt_id (int, optional): Prompt ID for organizing outputs
            iteration (int, optional): Iteration number
            
        Returns:
            dict: Result of processing
        """
        try:
            # If prompt_id not provided, use a default
            if prompt_id is None:
                prompt_id = 1
            
            if status_callback:
                status_callback(f"Processing circuit in LTSpice...")
                
            # Process using the LTSpice interface directly
            result = self.ltspice.process_circuit(
                asc_code,
                prompt_id=prompt_id,
                iteration=iteration
            )
            
            if not result:
                raise LTSpiceError("LTSpice processing failed")
                
            updated_asc_path, image_path = result
            
            # Read the updated ASC code
            with open(updated_asc_path, 'r', encoding='utf-8', errors='replace') as f:
                updated_asc_code = f.read()
            
            return {
                "success": True,
                "asc_path": updated_asc_path,
                "image_path": image_path,
                "asc_code": updated_asc_code
            }
            
        except Exception as e:
            logger.error(f"Manual circuit processing error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def process_existing_circuit(self, asc_code, prompt_id=None, iteration=0, status_callback=None):
        """
        Process an existing circuit that was loaded or edited
        
        Args:
            asc_code (str): ASC code
            prompt_id (int, optional): Prompt ID for organizing outputs
            iteration (int, optional): Iteration number
            status_callback (function, optional): Callback for status updates
            
        Returns:
            dict: Result of processing
        """
        try:
            # Default prompt_id if not provided
            if prompt_id is None:
                prompt_id = 1
            
            # Status update
            if status_callback:
                status_callback("Processing existing circuit in LTSpice...")
            
            # Process with LTSpice
            result = self.ltspice.process_circuit(
                asc_code,
                prompt_id=prompt_id,
                iteration=iteration
            )
            
            if not result:
                raise LTSpiceError("LTSpice processing failed")
                
            updated_asc_path, image_path = result
            
            # Read updated ASC code
            with open(updated_asc_path, 'r', encoding='utf-8', errors='replace') as f:
                updated_asc_code = f.read()
            
            return {
                "success": True,
                "asc_path": updated_asc_path,
                "image_path": image_path,
                "asc_code": updated_asc_code
            }
            
        except Exception as e:
            logger.error(f"Existing circuit processing error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }


File: .\electroninja\core\__init__.py
-------------------------------------
from electroninja.core.circuit_processor import CircuitProcessor
from electroninja.core.feedback.loop_manager import FeedbackLoopManager
from electroninja.core.ltspice.interface import LTSpiceInterface

__all__ = ['CircuitProcessor', 'FeedbackLoopManager', 'LTSpiceInterface']

File: .\electroninja\core\feedback\evaluator.py
-----------------------------------------------
# electroninja/core/feedback/evaluator.py
import logging
import re

logger = logging.getLogger('electroninja')

class FeedbackEvaluator:
    """Evaluates circuit feedback to determine success or next steps"""
    
    def __init__(self):
        logger.info("FeedbackEvaluator initialized")
    
    def is_circuit_verified(self, vision_feedback):
        """
        Check if the vision feedback indicates the circuit is verified
        
        Args:
            vision_feedback (str): Vision feedback from vision model
            
        Returns:
            bool: True if verified, False otherwise
        """
        # With OpenAI, verification is simply if the feedback is exactly 'Y'
        is_verified = vision_feedback.strip() == 'Y'
        
        verification_message = "Circuit passed verification" if is_verified else "Circuit failed verification"
        logger.info(f"{verification_message}")
            
        return is_verified
        
    def extract_feedback_points(self, vision_feedback):
        """
        Extract key feedback points from vision feedback
        
        Args:
            vision_feedback (str): Vision feedback
            
        Returns:
            list: List of feedback points
        """
        # If verified (just 'Y'), there are no feedback points
        if self.is_circuit_verified(vision_feedback):
            return ["Circuit correctly implements the request"]
        
        # For more detailed analysis, try to extract structured points
        # Look for numbered points (1., 2., etc.) or paragraph boundaries
        numbered_pattern = r'\b\d+\.[\s]+(.*?)(?=\b\d+\.[\s]+|$)'
        numbered_matches = re.findall(numbered_pattern, vision_feedback)
        
        if numbered_matches:
            # If we found numbered points, return those
            return [point.strip() for point in numbered_matches if point.strip()]
        
        # Otherwise split by paragraphs
        paragraphs = vision_feedback.split('\n\n')
        if len(paragraphs) > 1:
            return [p.strip() for p in paragraphs if p.strip()]
        
        # As a fallback, split by sentences
        sentences = re.split(r'(?<=[.!?])\s+', vision_feedback.strip())
        meaningful_sentences = [s.strip() for s in sentences if len(s.strip()) > 15]  # Only reasonably long sentences
        
        if meaningful_sentences:
            return meaningful_sentences
        
        # Final fallback
        return ["Circuit does not correctly implement the request"]
        
    def format_iteration_result(self, state, current_asc, image_path, feedback, success=False):
        """
        Format the result of an iteration
        
        Args:
            state (dict): Current state
            current_asc (str): Current ASC code
            image_path (str): Path to the circuit image
            feedback (str): Vision feedback
            success (bool): Whether the circuit is verified
            
        Returns:
            dict: Formatted result
        """
        # Extract feedback points
        feedback_points = self.extract_feedback_points(feedback)
        
        return {
            "success": success,
            "iterations": state["iteration"],
            "asc_code": current_asc,
            "image_path": image_path,
            "feedback": feedback,
            "feedback_points": feedback_points,
            "history": state["history"]
        }

File: .\electroninja\core\feedback\loop_manager.py
--------------------------------------------------
import os
import logging
from electroninja.config.settings import Config
from electroninja.core.ltspice.interface import LTSpiceInterface
from electroninja.llm.providers.openai import OpenAIProvider
from electroninja.llm.vector_store import VectorStore
from electroninja.utils.file_operations import save_file
from electroninja.utils.error_handler import LTSpiceError

logger = logging.getLogger('electroninja')

class FeedbackLoopManager:
    """
    A dummy implementation of FeedbackLoopManager.
    In a full implementation, this class would manage the iterative feedback loop,
    refining the circuit design until it meets verification criteria.
    """
    def __init__(self, config=None):
        self.config = config or Config()
        # Initialize additional components (state tracker, evaluators, etc.) as needed.
    
    def process_request(self, request, examples=None, status_callback=None):
        """
        Process a circuit request iteratively.
        
        For this dummy implementation, simply simulate a successful process.
        
        Args:
            request (str): The user request for circuit design.
            examples (list): List of similar circuit examples (optional).
            status_callback (function): Optional callback for status updates.
            
        Returns:
            dict: Simulated result of processing.
        """
        if status_callback:
            status_callback("Processing request in FeedbackLoopManager...")
        # Simulate processing and return a dummy success result.
        return {
            "success": True,
            "asc_code": "dummy ASC code generated for request: " + request,
            "asc_path": "dummy_path.asc",
            "image_path": "dummy_image.png",
            "history": [{"iteration": 0, "asc_code": "dummy ASC code"}]
        }

class CircuitProcessor:
    """Main entry point for circuit processing."""
    
    def __init__(self, config=None):
        self.config = config or Config()
        self.feedback_manager = FeedbackLoopManager(self.config)
        self.ltspice = LTSpiceInterface(self.config)
        self.llm_provider = OpenAIProvider(self.config)
        self.vector_store = VectorStore(self.config)
        
        # Load vector store
        self.vector_store.load()
        
    def process_circuit_request(self, request, status_callback=None):
        """
        Process a circuit request.
        
        Args:
            request (str): User request.
            status_callback (function): Callback for status updates.
            
        Returns:
            dict: Result of processing.
        """
        try:
            # Search for similar examples
            examples = self.vector_store.search(request)
            
            # Process the request using the feedback manager
            result = self.feedback_manager.process_request(
                request,
                examples=examples,
                status_callback=status_callback
            )
            
            return result
            
        except Exception as e:
            logger.error(f"Circuit processing error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
            
    def is_circuit_request(self, message):
        """
        Check if a message is a circuit request.
        
        Args:
            message (str): User message.
            
        Returns:
            bool: True if it's a circuit request.
        """
        keywords = ["circuit", "resistor", "capacitor", "oscillator", "filter", 
                    "transistor", "diode", "voltage", "current", "amplifier"]
        return any(kw in message.lower() for kw in keywords)
        
    def manual_circuit_processing(self, asc_code, status_callback=None, prompt_id=None, iteration=0):
        """
        Process a circuit manually.
        
        Args:
            asc_code (str): ASC code.
            status_callback (function): Callback for status updates.
            prompt_id (int, optional): Prompt ID for organizing outputs.
            iteration (int, optional): Iteration number.
            
        Returns:
            dict: Result of processing.
        """
        try:
            # If prompt_id not provided, use a default
            if prompt_id is None:
                prompt_id = 1
            
            if status_callback:
                status_callback("Processing circuit in LTSpice...")
                
            # Process using the LTSpice interface directly
            result = self.ltspice.process_circuit(
                asc_code,
                prompt_id=prompt_id,
                iteration=iteration
            )
            
            if not result:
                raise LTSpiceError("LTSpice processing failed")
                
            updated_asc_path, image_path = result
            
            # Read the updated ASC code
            with open(updated_asc_path, 'r', encoding='utf-8', errors='replace') as f:
                updated_asc_code = f.read()
            
            return {
                "success": True,
                "asc_path": updated_asc_path,
                "image_path": image_path,
                "asc_code": updated_asc_code
            }
            
        except Exception as e:
            logger.error(f"Manual circuit processing error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def process_existing_circuit(self, asc_code, prompt_id=None, iteration=0, status_callback=None):
        """
        Process an existing circuit that was loaded or edited.
        
        Args:
            asc_code (str): ASC code.
            prompt_id (int, optional): Prompt ID for organizing outputs.
            iteration (int, optional): Iteration number.
            status_callback (function, optional): Callback for status updates.
            
        Returns:
            dict: Result of processing.
        """
        try:
            # Default prompt_id if not provided
            if prompt_id is None:
                prompt_id = 1
            
            # Status update
            if status_callback:
                status_callback("Processing existing circuit in LTSpice...")
            
            # Process with LTSpice
            result = self.ltspice.process_circuit(
                asc_code,
                prompt_id=prompt_id,
                iteration=iteration
            )
            
            if not result:
                raise LTSpiceError("LTSpice processing failed")
                
            updated_asc_path, image_path = result
            
            # Read updated ASC code
            with open(updated_asc_path, 'r', encoding='utf-8', errors='replace') as f:
                updated_asc_code = f.read()
            
            return {
                "success": True,
                "asc_path": updated_asc_path,
                "image_path": image_path,
                "asc_code": updated_asc_code
            }
            
        except Exception as e:
            logger.error(f"Existing circuit processing error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }


File: .\electroninja\core\feedback\state_tracker.py
---------------------------------------------------
# state_tracker.py

import logging
from copy import deepcopy

logger = logging.getLogger('electroninja')

class StateTracker:
    """Tracks the state of the feedback loop"""
    
    def __init__(self, request, max_iterations=5):
        self.state = {
            "request": request,
            "iteration": 0,
            "history": [],
            "max_iterations": max_iterations,
            "success": False
        }
        
    def get_state(self):
        """Get the current state"""
        return deepcopy(self.state)
        
    def increment_iteration(self):
        """Increment the iteration counter"""
        self.state["iteration"] += 1
        logger.info(f"Iteration incremented to {self.state['iteration']}")
        return self.state["iteration"]
        
    def add_asc_attempt(self, iteration, asc_code):
        """Add an ASC code attempt to history"""
        self.state["history"].append({
            "iteration": iteration,
            "asc_code": asc_code
        })
        logger.info(f"Added ASC attempt for iteration {iteration}")
        
    def add_vision_feedback(self, iteration, feedback):
        """Add vision feedback to history"""
        self.state["history"].append({
            "iteration": iteration,
            "vision_feedback": feedback
        })
        logger.info(f"Added vision feedback for iteration {iteration}")
        
    def set_success(self, success):
        """Set the success flag"""
        self.state["success"] = success
        logger.info(f"Set success flag to {success}")
        
    def is_max_iterations_reached(self):
        """Check if max iterations is reached"""
        return self.state["iteration"] >= self.state["max_iterations"]
        
    def get_iteration(self):
        """Get the current iteration"""
        return self.state["iteration"]
        
    def get_history(self):
        """Get the conversation history"""
        return deepcopy(self.state["history"])
        
    def get_request(self):
        """Get the original request"""
        return self.state["request"]

File: .\electroninja\core\feedback\__init__.py
----------------------------------------------
from electroninja.core.feedback.loop_manager import FeedbackLoopManager
from electroninja.core.feedback.evaluator import FeedbackEvaluator
from electroninja.core.feedback.state_tracker import StateTracker

__all__ = ['FeedbackLoopManager', 'FeedbackEvaluator', 'StateTracker']

File: .\electroninja\core\ltspice\interface.py
----------------------------------------------
import os
import re
import time
import logging
import platform
import subprocess
import shutil
import psutil
from electroninja.config.settings import Config
from electroninja.utils.error_handler import LTSpiceError
from electroninja.utils.file_operations import save_file
import fitz  # PyMuPDF for PDF to image conversion
from PIL import Image
from pywinauto import Application, timings
from pywinauto.keyboard import send_keys  # For global keystroke sending

# Set up logging
logger = logging.getLogger('electroninja')

class LTSpiceInterface:
    """
    A simple LTSpice automation interface that:
      1. Opens an ASC file in LTSpice.
      2. Presses Ctrl+P to open the print dialog.
      3. Immediately sends a global Enter keystroke to accept the default printer.
      4. Waits for the Save Print Output As dialog, pastes the desired PDF path, and presses Enter.
      5. Converts the generated PDF to a PNG image and removes the PDF.
    """
    
    def __init__(self, config=None):
        self.config = config or Config()
        self.ltspice_path = self.config.LTSPICE_PATH
        if not os.path.exists(self.ltspice_path):
            logger.warning(f"LTSpice executable not found at '{self.ltspice_path}'")
        else:
            logger.info(f"LTSpice found at '{self.ltspice_path}'")
        try:
            timings.set_timeout_period(3.0)
        except Exception as e:
            logger.warning(f"Could not set pywinauto timings: {e}")
    
    def process_circuit(self, asc_code_or_path, prompt_id=1, iteration=0):
        """
        Process a circuit by:
          - Creating output folders.
          - Writing/copying the ASC file.
          - Closing any running LTSpice instances.
          - Launching LTSpice and automating the print-to-PDF process.
          - Converting the resulting PDF to a PNG image.
          - Removing the temporary PDF.
          
        Returns (asc_path, image_path) on success, or None on failure.
        """
        if platform.system() != "Windows":
            raise LTSpiceError("This process only works on Windows.")
        
        output_dir = self._create_output_folders(prompt_id, iteration)
        asc_path = os.path.join(output_dir, "code.asc")
        pdf_path = os.path.join(output_dir, "code.pdf")
        image_path = os.path.join(output_dir, "image.png")
        
        # Write or copy the ASC file.
        if isinstance(asc_code_or_path, str) and not os.path.isfile(asc_code_or_path):
            self._write_asc(asc_code_or_path, asc_path)
        elif os.path.isfile(asc_code_or_path) and asc_code_or_path != asc_path:
            shutil.copy(asc_code_or_path, asc_path)
            logger.info(f"Copied ASC file from {asc_code_or_path} to {asc_path}")
        
        # Close any running LTSpice processes.
        self._close_ltspice(quiet=True)
        
        # Automate LTSpice to print the circuit to a PDF.
        if not self._run_ltspice_gui_and_print(asc_path, pdf_path):
            logger.error("Failed to automate LTSpice print to PDF.")
            return None
        
        if not os.path.exists(pdf_path):
            logger.error(f"PDF file was not created at {pdf_path}")
            return None
        
        # Convert the PDF to a PNG image.
        if not self._convert_pdf_to_png(pdf_path, image_path):
            logger.error("Failed to convert PDF to PNG.")
            return None
        
        try:
            os.remove(pdf_path)
            logger.info(f"Removed temporary PDF file: {pdf_path}")
        except Exception as e:
            logger.warning(f"Could not remove PDF file: {e}")
        
        logger.info(f"Successfully processed circuit. ASC: {asc_path}, Image: {image_path}")
        return asc_path, image_path
    
    def _wait_for_window(self, app, title_pattern, timeout=3, retry_interval=0.1):
        """
        Wait for a window whose title matches title_pattern.
        """
        start_time = time.time()
        current_retry = retry_interval
        while time.time() - start_time < timeout:
            for win in app.windows():
                if re.search(title_pattern, win.window_text(), re.IGNORECASE):
                    return win
            time.sleep(current_retry)
            current_retry = min(current_retry * 1.5, 0.5)
        available_titles = [w.window_text() for w in app.windows()]
        logger.debug(f"Available window titles: {available_titles}")
        return None
    
    def _run_ltspice_gui_and_print(self, asc_path, pdf_path):
        """
        Automate printing:
          1. Open the ASC file in LTSpice.
          2. Wait for LTSpice to load.
          3. Press Ctrl+P to open the print dialog.
          4. Immediately send a global Enter to accept default printer.
          5. Wait for the Save Print Output As dialog, paste the PDF path, and press Enter.
          6. Wait for the PDF to be generated.
          7. Close LTSpice after PDF generation.
        """
        logger.info(f"Opening LTSpice GUI for {asc_path}")
        proc = None
        try:
            # Launch LTSpice.
            proc = subprocess.Popen([self.ltspice_path, asc_path], shell=False)
            time.sleep(0.001)  # Wait for LTSpice to load
            
            # Connect to LTSpice.
            app = Application().connect(process=proc.pid)
            main_window = app.top_window()
            main_window.set_focus()
            logger.info("Connected to LTSpice and focused main window")
            time.sleep(0.001)
            
            # Step 1: Press Ctrl+P.
            main_window.type_keys("^p", pause=0.0001)
            logger.info("Sent Ctrl+P to open print dialog")
            time.sleep(0.001)
            
            # Step 2: Immediately send global Enter to accept default printer.
            send_keys("{ENTER}", pause=0.0001)
            logger.info("Sent global Enter to accept default printer")
            time.sleep(0.001)
            
            # Step 3: Wait for the Save Print Output As dialog.
            save_dlg = self._wait_for_window(app, r".*save print output as.*", timeout=10)
            if not save_dlg:
                logger.error("Save dialog not found")
                self._close_ltspice()
                return False
            save_dlg.set_focus()
            logger.info(f"Found save dialog: {save_dlg.window_text()}")
            time.sleep(0.001)
            
            # Step 4: Paste the PDF path.
            save_dlg.type_keys("^a{BACKSPACE}", pause=0.0001)
            time.sleep(0.001)
            save_dlg.type_keys(pdf_path, pause=0.0001)
            logger.info(f"Pasted PDF path: {pdf_path}")
            time.sleep(0.001)
            
            # Step 5: Press Enter to save PDF.
            save_dlg.type_keys("{ENTER}", pause=0.0001)
            logger.info("Pressed Enter to save PDF")
            time.sleep(1.3)  # Wait 1.3 seconds for PDF generation THIS CANNON BE REDUCED I TRIED
            
            # Step 6: Now explicitly close LTSpice after PDF generation
            self._close_ltspice(quiet=False)
            logger.info("Closed LTSpice after PDF generation")
            
            # Ensure PDF exists before returning success
            if os.path.exists(pdf_path):
                return True
            else:
                logger.error("PDF file not created after waiting")
                return False
                
        except Exception as e:
            logger.error(f"Error automating LTSpice: {e}")
            if proc:
                try:
                    proc.terminate()
                except:
                    pass
            self._close_ltspice()
            return False
    
    def _wait_for_file_creation(self, file_path, max_wait=15, check_interval=0.2, min_size=10000):
        """
        Wait until the file exists and its size is stable and above a minimum threshold.
        """
        start_time = time.time()
        last_size = 0
        while time.time() - start_time < max_wait:
            if os.path.exists(file_path):
                current_size = os.path.getsize(file_path)
                if current_size >= min_size and current_size == last_size:
                    return True
                last_size = current_size
            time.sleep(check_interval)
        return False
    
    def _close_ltspice(self, quiet=False):
        """
        Close all running LTSpice processes.
        """
        try:
            ltspice_procs = []
            for proc in psutil.process_iter(['pid', 'name']):
                if 'LTspice' in proc.info['name']:
                    ltspice_procs.append(proc.info['pid'])
            if not ltspice_procs:
                if not quiet:
                    logger.info("No LTSpice processes found to close")
                return
            for pid in ltspice_procs:
                try:
                    if not quiet:
                        logger.info(f"Closing LTSpice process: {pid}")
                    psutil.Process(pid).terminate()
                except Exception:
                    pass
            if ltspice_procs:
                time.sleep(0.1)
            for proc in psutil.process_iter(['pid', 'name']):
                if 'LTspice' in proc.info['name']:
                    try:
                        psutil.Process(proc.info['pid']).kill()
                        if not quiet:
                            logger.info(f"Force killed LTSpice process: {proc.info['pid']}")
                    except Exception:
                        pass
        except Exception as e:
            if not quiet:
                logger.warning(f"Error closing LTSpice: {e}")
    
    def _convert_pdf_to_png(self, pdf_path, image_path):
        """
        Convert the first page of the PDF to a PNG image.
        Renders at 3x zoom, crops to the bounding box, centers on a white square,
        and saves with optimization.
        """
        try:
            doc = fitz.open(pdf_path)
            page = doc[0]
            zoom = 3.0
            mat = fitz.Matrix(zoom, zoom)
            pix = page.get_pixmap(matrix=mat)
            pix.save(image_path)
            doc.close()
            
            with Image.open(image_path) as im:
                bbox = im.getbbox()
                if bbox:
                    im_cropped = im.crop(bbox)
                    w, h = im_cropped.size
                    new_h = int(h * 0.90)
                    im_cropped = im_cropped.crop((0, 0, w, new_h))
                    final_size = max(im_cropped.width, im_cropped.height)
                    final_img = Image.new("RGB", (final_size, final_size), "white")
                    offset_x = (final_size - im_cropped.width) // 2
                    offset_y = (final_size - im_cropped.height) // 2
                    final_img.paste(im_cropped, (offset_x, offset_y))
                    final_img.save(image_path, optimize=True, quality=90)
                else:
                    w, h = im.size
                    final_size = max(w, h)
                    final_img = Image.new("RGB", (final_size, final_size), "white")
                    final_img.paste(im, ((final_size - w) // 2, (final_size - h) // 2))
                    final_img.save(image_path, optimize=True, quality=90)
            logger.info(f"Converted PDF to PNG and cropped: {image_path}")
            return True
        except Exception as e:
            logger.error(f"Error converting PDF to PNG: {e}")
            return False
    
    def _create_output_folders(self, prompt_id, iteration):
        """
        Create the output folder structure: {OUTPUT_DIR}/prompt{prompt_id}/output{iteration}
        """
        prompt_dir = os.path.join(self.config.OUTPUT_DIR, f"prompt{prompt_id}")
        os.makedirs(prompt_dir, exist_ok=True)
        output_dir = os.path.join(prompt_dir, f"output{iteration}")
        os.makedirs(output_dir, exist_ok=True)
        logger.info(f"Created output structure: {output_dir}")
        return output_dir
    
    def _write_asc(self, asc_code_or_path, asc_path):
        """
        Write the ASC file content to asc_path.
        If asc_code_or_path is a file, read its content; otherwise, use it directly.
        """
        if os.path.isfile(asc_code_or_path):
            with open(asc_code_or_path, "r", encoding="utf-8", errors="replace") as src:
                asc_data = src.read()
        else:
            asc_data = asc_code_or_path
        save_file(asc_data, asc_path)
        logger.info(f"Wrote ASC file: {asc_path}")

File: .\electroninja\core\ltspice\__init__.py
---------------------------------------------
from electroninja.core.ltspice.interface import LTSpiceInterface

__all__ = ['LTSpiceInterface']

File: .\electroninja\llm\vector_store.py
----------------------------------------
# vector_store.py

import os
import numpy as np
import logging
import pickle
import json
import openai
from typing import List, Dict, Any, Optional
from electroninja.config.settings import Config
from electroninja.utils.error_handler import ModelError, FileError

logger = logging.getLogger('electroninja')

class VectorStore:
    """Vector database for storing and retrieving circuit examples using semantic search"""
    
    def __init__(self, config=None):
        self.config = config or Config()
        self.embedding_model = "text-embedding-3-small"
        self.vector_size = 1536
        self.metadata_list = []
        self.index = None
        
        # Set OpenAI API key
        openai.api_key = self.config.OPENAI_API_KEY
        
        # Import FAISS
        try:
            import faiss
            self.faiss = faiss
            self.index = faiss.IndexFlatL2(self.vector_size)
            logger.info("FAISS index initialized")
        except ImportError:
            logger.error("Failed to import FAISS. Vector search will not be available.")
            self.faiss = None
            
    def load(self):
        """
        Load the index and metadata from disk, or build from metadata.json if not found
        
        Returns:
            bool: True if successfully loaded or built, False otherwise
        """
        try:
            if self.faiss is None:
                logger.error("FAISS is not available. Cannot load index.")
                return False
                
            index_path = self.config.VECTOR_DB_INDEX
            metadata_path = self.config.VECTOR_DB_METADATA
            
            # Try to load existing index and metadata
            if os.path.exists(index_path) and os.path.exists(metadata_path):
                self.index = self.faiss.read_index(index_path)
                
                with open(metadata_path, "rb") as f:
                    self.metadata_list = pickle.load(f)
                    
                logger.info(f"Loaded index with {len(self.metadata_list)} documents")
                return True
            else:
                # If index doesn't exist, try to build from metadata.json
                logger.warning("Saved index or metadata file not found. Attempting to build from metadata.json")
                return self._build_index_from_metadata()
                
        except Exception as e:
            logger.error(f"Failed to load index: {str(e)}")
            return False
    
    def _build_index_from_metadata(self):
        """
        Build the index from metadata.json file
        
        Returns:
            bool: True if successfully built, False otherwise
        """
        try:
            metadata_json_path = os.path.join(self.config.EXAMPLES_DIR, "metadata.json")
            
            if not os.path.exists(metadata_json_path):
                logger.error(f"Metadata file not found: {metadata_json_path}")
                return False
                
            with open(metadata_json_path, "r", encoding="utf-8") as f:
                examples = json.load(f)
                
            logger.info(f"Found {len(examples)} examples in metadata.json")
            
            # Process each example
            successful_count = 0
            for i, example in enumerate(examples, 1):
                asc_path = example.get("asc_path")
                description = example.get("description", "No description")
                
                # Check if path is valid
                if not asc_path:
                    logger.warning(f"Example {i}: Missing asc_path")
                    continue
                
                # Convert relative path if needed
                if not os.path.isabs(asc_path):
                    asc_path = os.path.join(self.config.BASE_DIR, asc_path)
                
                if os.path.exists(asc_path):
                    try:
                        with open(asc_path, "r", encoding="utf-8") as asc_file:
                            asc_code = asc_file.read()
                        
                        # Combine description and ASC code for embedding
                        combined_text = f"{description}\n\nASC CODE:\n{asc_code}"
                        
                        # Add to index
                        if self.add_document(combined_text, metadata={"asc_path": asc_path, "description": description}):
                            successful_count += 1
                            logger.info(f"Added example {i}: {os.path.basename(asc_path)}")
                    except Exception as e:
                        logger.warning(f"Failed to process {asc_path}: {str(e)}")
                else:
                    logger.warning(f"File not found: {asc_path}")
            
            # Save the built index
            if successful_count > 0:
                self.save()
                logger.info(f"Built and saved index with {successful_count} documents")
                return True
            else:
                logger.error("Failed to build index: No valid examples found")
                return False
                
        except Exception as e:
            logger.error(f"Failed to build index from metadata: {str(e)}")
            return False
            
    def save(self):
        """
        Save the index and metadata to disk
        
        Returns:
            bool: True if successfully saved, False otherwise
        """
        try:
            if self.faiss is None or self.index is None:
                logger.error("FAISS is not available or index is not initialized.")
                return False
            
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(self.config.VECTOR_DB_INDEX), exist_ok=True)
            
            # Save FAISS index
            self.faiss.write_index(self.index, self.config.VECTOR_DB_INDEX)
            
            # Save metadata
            with open(self.config.VECTOR_DB_METADATA, "wb") as f:
                pickle.dump(self.metadata_list, f)
                
            logger.info(f"Saved index with {len(self.metadata_list)} documents")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save index: {str(e)}")
            return False
            
    def add_document(self, asc_code: str, metadata: Optional[Dict[str, Any]] = None):
        """
        Add a document to the vector store
        
        Args:
            asc_code (str): ASC code or combined text to embed
            metadata (dict, optional): Additional metadata
            
        Returns:
            bool: True if successfully added, False otherwise
        """
        try:
            if self.faiss is None or self.index is None:
                logger.error("FAISS is not available or index is not initialized.")
                return False
                
            # Embed the text
            vector = self.embed_text(asc_code)
            vector = np.expand_dims(vector, axis=0)  # shape: (1, vector_size)
            
            # Add to FAISS index
            self.index.add(vector)
            
            # Add to metadata list
            doc = {"asc_code": asc_code}
            if metadata:
                doc.update(metadata)
            self.metadata_list.append(doc)
            
            logger.info(f"Document added. Total documents: {len(self.metadata_list)}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to add document: {str(e)}")
            return False
            
    def search(self, query_text: str, top_k: int = 3) -> List[Dict[str, Any]]:
        """
        Search for similar documents
        
        Args:
            query_text (str): Query text to search for
            top_k (int): Number of results to return
            
        Returns:
            list: List of matching documents with metadata and scores
        """
        try:
            if self.faiss is None or self.index is None:
                logger.error("FAISS is not available or index is not initialized.")
                return []
                
            # Check if database is empty
            if len(self.metadata_list) == 0:
                # Try to build index from metadata if empty
                logger.warning("No documents in the database. Attempting to build from metadata.json")
                if not self._build_index_from_metadata():
                    return []
            
            # Adjust top_k to not exceed number of documents
            effective_top_k = min(top_k, len(self.metadata_list))
            
            # Embed the query
            query_vector = self.embed_text(query_text)
            query_vector = np.expand_dims(query_vector, axis=0)
            
            # Search
            distances, indices = self.index.search(query_vector, effective_top_k)
            
            # Build results
            results = []
            for i, idx in enumerate(indices[0]):
                if idx == -1 or idx >= len(self.metadata_list):
                    continue
                
                # Get the metadata and full stored text
                metadata = {k: v for k, v in self.metadata_list[idx].items() if k != "asc_code"}
                full_text = self.metadata_list[idx].get("asc_code", "")
                
                # Extract just the ASC code portion to avoid duplication
                # If the format is consistent with "ASC CODE:" marker
                asc_code = full_text
                if "\nASC CODE:\n" in full_text:
                    asc_code = full_text.split("\nASC CODE:\n", 1)[1]
                
                results.append({
                    "asc_code": asc_code,
                    "metadata": metadata,
                    "score": float(distances[0][i])
                })
                
            logger.info(f"Found {len(results)} similar documents for query: '{query_text[:50]}...'")
            return results
            
        except Exception as e:
            logger.error(f"Search error: {str(e)}")
            return []
            
    def embed_text(self, text: str) -> np.ndarray:
        """
        Generate an embedding for text
        
        Args:
            text (str): Text to embed
            
        Returns:
            np.ndarray: Embedding vector
            
        Raises:
            ModelError: If embedding fails
        """
        try:
            # Clean text
            text = text.replace("\n", " ")
            
            # Get embedding from OpenAI
            response = openai.Embedding.create(
                input=[text],
                model=self.embedding_model
            )
            
            # Extract embedding
            embedding = response["data"][0]["embedding"]
            
            return np.array(embedding, dtype=np.float32)
            
        except Exception as e:
            logger.error(f"Embedding error: {str(e)}")
            raise ModelError(f"Failed to generate embedding: {str(e)}")
            
    def get_document_count(self):
        """Get the number of documents in the index"""
        return len(self.metadata_list)
        
    def clear(self):
        """Clear the index and metadata"""
        if self.faiss is not None:
            self.index = self.faiss.IndexFlatL2(self.vector_size)
            self.metadata_list = []
            logger.info("Index and metadata cleared")
            return True
        return False

File: .\electroninja\llm\vision_analyser.py
-------------------------------------------
# electroninja/llm/vision_analyser.py
import os
import logging
import base64
import openai
from electroninja.config.settings import Config
from electroninja.utils.error_handler import ModelError
from electroninja.llm.prompts.circuit_prompts import VISION_IMAGE_ANALYSIS_PROMPT

logger = logging.getLogger('electroninja')

class VisionAnalyzer:
    """Analyzes circuit images using OpenAI's vision model"""
    
    def __init__(self, config=None):
        self.config = config or Config()
        self.model = self.config.OPENAI_VISION_MODEL  # Should be "gpt-4o"
        openai.api_key = self.config.OPENAI_API_KEY
        logger.info(f"Vision Analyzer initialized with OpenAI model: {self.model}")
        
    def analyze_circuit_image(self, image_path, original_request):
        """
        Analyze a circuit image to determine if it satisfies the user's request
        
        Args:
            image_path (str): Path to the circuit image
            original_request (str): Original user request
            
        Returns:
            str: Analysis result with 'Y' if verified, or detailed feedback
        """
        try:
            logger.info(f"Starting analysis of circuit image: {image_path}")
            logger.info(f"Original request: '{original_request}'")
            
            if not os.path.exists(image_path):
                error_msg = f"Image file not found: {image_path}"
                logger.error(error_msg)
                raise ModelError(error_msg)
            
            # Get file size for logging
            file_size = os.path.getsize(image_path)
            logger.info(f"Image file size: {file_size} bytes")
                
            # Encode image
            with open(image_path, "rb") as image_file:
                image_data = base64.b64encode(image_file.read()).decode('utf-8')
                logger.info(f"Successfully encoded image data (length: {len(image_data)})")
                
            # Use the OpenAI prompt template
            prompt = VISION_IMAGE_ANALYSIS_PROMPT.format(original_request=original_request)
            
            logger.info(f"Sending request to OpenAI vision model ({self.model})...")
            
            # Call OpenAI API
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/png;base64,{image_data}"
                                }
                            }
                        ]
                    }
                ]
            )
            
            # Extract and process analysis
            analysis = response.choices[0].message.content.strip()
            
            # No logging of raw output to avoid encoding issues
            # Just log the status
            is_verified = analysis.strip() == 'Y'
            verification_status = "VERIFIED" if is_verified else "NOT VERIFIED"
            logger.info(f"Vision analysis complete: Circuit {verification_status}")
            
            # Return the raw analysis
            return analysis
            
        except Exception as e:
            error_msg = f"Vision analysis error: {str(e)}"
            logger.error(error_msg)
            raise ModelError(error_msg)

File: .\electroninja\llm\__init__.py
------------------------------------
from electroninja.llm.providers.openai import OpenAIProvider
from electroninja.llm.vector_store import VectorStore
from electroninja.llm.vision_analyser import VisionAnalyzer

__all__ = ['OpenAIProvider', 'VectorStore', 'VisionAnalyzer']

File: .\electroninja\llm\prompts\chat_prompts.py
------------------------------------------------
# electroninja/llm/prompts/chat_prompts.py


# Circuit request for 4o-mini
CIRCUIT_CHAT_PROMPT = (
    "If the client's message is directly related to circuit design, reply with a concise, confident greeting, "
    "and inform the client that the circuit is being generated. DO NOT include any .asc code in your response. "
    "User prompt: {prompt}\n"
    "Provide a brief, assertive message that assures the client that the circuit is in process."
)

# Non-circuit request for 4o-mini
NON_CIRCUIT_CHAT_PROMPT = (
    "The following request is NOT related to electrical engineering or circuits.\n"
    "User prompt: {prompt}\n"
    "Politely inform the user that you are an electrical engineering assistant and can only help with "
    "circuit design requests. Be courteous but clear about your specific focus area."
)

# Vision feedback response prompt for gpt-4o-mini
VISION_FEEDBACK_PROMPT = (
    "Below is feedback from a vision model about a circuit implementation you are building:\n\n"
    "{vision_feedback}\n\n"
    "Generate a brief, user-friendly response that:\n"
    "1. If the feedback is exactly 'Y', inform the user that their circuit is complete and they can ask for modifications if needed.\n"
    "2. If the feedback contains issues or errors, briefly summarize the main problems identified and assure the user you're working to fix them.\n"
    "In the 2nd case your answer should be of the tone: The current circuit I made has [issues from feedback] but I am working to fix them."
    "Keep your response conversational, concise (2-3 sentences), and non-technical. Do not include any circuit code in your response."
)

File: .\electroninja\llm\prompts\circuit_prompts.py
---------------------------------------------------
# electroninja/llm/prompts/circuit_prompts.py

# General instruction for the agent
GENERAL_INSTRUCTION = (
    "You are a world-class electrical engineer with absolute authority in LTSpice circuit design. "
    "You write .asc files with unwavering precision. When a client asks you to build a circuit, "
    "you must respond with clear, definitive statements and the exact .asc code required."
)

# Safety prompt to ensure the agent stays on topic
SAFETY_FOR_AGENT = (
    "IMPORTANT: You must strictly restrict your responses to electrical engineering topics only. "
    "If the client's message is irrelevant to electrical engineering or circuits, respond ONLY with "
    "the single letter 'N'. There should be no additional commentary, explanations, or attempts to "
    "help with non-circuit topics. You are exclusively an electrical circuit design assistant."
)

# ASC generation prompt
ASC_GENERATION_PROMPT = (
    "Generate the complete .asc code for the circuit the user requested. "
    "It is CRUCIAL that your response contains only the valid .asc code with no extra explanation. "
    "Your statements must be forceful, clear, and unequivocal, ensuring that the code can be directly imported into LTSpice. "
    "If the request is not related to circuit design, respond with only the letter 'N'."
)

# Enhanced refinement prompt template for improved circuit refinement
REFINEMENT_PROMPT_TEMPLATE = (
    "Based on the previous attempts and vision feedback, provide a revised complete .asc code "
    "for a circuit that meets the original user's request. "
    
    "CRITICAL REQUIREMENTS:\n"
    "1. Pay careful attention to the specific issues identified in the vision feedback\n"
    "2. Fix all component connections, values, or structural problems mentioned\n"
    "3. Ensure your revised circuit properly implements the requested functionality\n"
    "4. Apply proper electrical engineering principles in your refinement\n\n"
    
    "Your answer must begin with 'Version 4' and contain ONLY valid LTSpice ASC code with "
    "no additional explanation, commentary, or text outside the ASC format."
)

# Vision feedback analysis prompt template - for analyzing vision model responses
VISION_ANALYSIS_PROMPT_TEMPLATE = (
    "Based on the conversation history and the latest vision feedback, "
    "provide a concise status update for the user. The update should explain why the current "
    "circuit attempt might be insufficient or what remains to be fixed, "
    "or indicate that the circuit is verified if it meets the request. "
    "Do not include any ASC code in your response."
)

# Vision image analysis prompt for OpenAI
VISION_IMAGE_ANALYSIS_PROMPT = (
    "You are an expert electrical engineer responsible for verifying circuit implementations. "
    "Your job is to analyze circuit schematics and determine if they correctly implement user requests. "
    
    "ANALYZE THIS CIRCUIT: Does the schematic correctly implement the following request? "
    "{original_request}\n\n"
    
    "Before giving your verdict, use this structured verification approach:\n"
    "Identify all components present in the circuit\n"
    "Determine how these components are connected (series vs parallel)\n"
    "Compare the circuit structure against standard definitions for the requested circuit type\n"
    "Check for any missing required components or incorrect connections\n\n"
    
    "OUTPUT FORMAT:\n"
    "- If the circuit CORRECTLY implements the request: Output ONLY the character 'Y' (nothing else)\n"
    "- If the circuit DOES NOT correctly implement the request: Provide a thorough analysis with:\n"
    "  1. What's wrong with the current implementation\n"
    "  2. Why it doesn't meet the requirements (cite engineering principles)\n"
    "  3. Detailed recommendations for fixing the circuit\n"
    "  4. Expected behavior after the modifications\n\n"
    
    "For circuits that are NOT verified, be detailed and educational in your response. Explain the "
    "engineering principles that apply, provide clear reasoning about the issues, and give comprehensive "
    "guidance for correction. Your explanation should be useful for someone learning circuit design."
)

# Circuit relevance evaluation prompt
CIRCUIT_RELEVANCE_EVALUATION_PROMPT = (
    "You are tasked with determining if a request is related to electrical engineering or circuits.\n"
    "Respond with ONLY a single letter: 'Y' if the request is related to electrical engineering or circuits, "
    "or 'N' if it's completely unrelated.\n\n"
    "Request: {prompt}\n\n"
    "Your response (Y/N):"
)

# RAG ASC generation prompt
RAG_ASC_GENERATION_PROMPT = (
    "Now, based on the examples above, generate the complete .asc code for a circuit that meets the user's request.\n\n"
    "CRITICAL INSTRUCTIONS:\n"
    "1. Your output MUST begin with 'Version 4' and contain ONLY valid LTSpice ASC code\n"
    "2. Do NOT include ANY descriptions, explanations, or comments before the ASC code\n"
    "3. Do NOT include ANY text that is not part of the ASC file format\n"
    "4. If the request is not related to circuits, respond only with 'N'\n\n"
    "OUTPUT FORMAT (exact):\n"
    "Version 4\n"
    "SHEET 1 ...\n"
    "... [remaining ASC code] ..."
)

File: .\electroninja\llm\prompts\__init__.py
--------------------------------------------
# electroninja/llm/prompts/__init__.py

from electroninja.llm.prompts.circuit_prompts import (
    GENERAL_INSTRUCTION,
    SAFETY_FOR_AGENT,
    ASC_GENERATION_PROMPT,
    REFINEMENT_PROMPT_TEMPLATE,
    VISION_ANALYSIS_PROMPT_TEMPLATE,
    VISION_IMAGE_ANALYSIS_PROMPT,
    CIRCUIT_RELEVANCE_EVALUATION_PROMPT,
    RAG_ASC_GENERATION_PROMPT
)

from electroninja.llm.prompts.chat_prompts import (
    CIRCUIT_CHAT_PROMPT,
    NON_CIRCUIT_CHAT_PROMPT,
    VISION_FEEDBACK_PROMPT
)

__all__ = [
    "GENERAL_INSTRUCTION",
    "SAFETY_FOR_AGENT",
    "ASC_GENERATION_PROMPT",
    "REFINEMENT_PROMPT_TEMPLATE",
    "VISION_ANALYSIS_PROMPT_TEMPLATE",
    "VISION_IMAGE_ANALYSIS_PROMPT",
    "CIRCUIT_RELEVANCE_EVALUATION_PROMPT",
    "RAG_ASC_GENERATION_PROMPT",
    "GREETING_PROMPT",
    "CIRCUIT_REQUEST_TEMPLATE",
    "DESIGN_IN_PROGRESS_TEMPLATE",
    "ITERATION_STATUS_TEMPLATE",
    "SUCCESS_TEMPLATE",
    "FAILURE_TEMPLATE",
    "GENERAL_HELP_RESPONSE",
    "LTSPICE_EXPLANATION",
    "CIRCUIT_CHAT_PROMPT",
    "NON_CIRCUIT_CHAT_PROMPT",
    "VISION_FEEDBACK_PROMPT"
]

File: .\electroninja\llm\providers\base.py
------------------------------------------
from abc import ABC, abstractmethod

class LLMProvider(ABC):
    """Base class for LLM providers"""
    
    @abstractmethod
    def generate_asc_code(self, prompt, examples=None):
        """
        Generate ASC code based on prompt and examples
        
        Args:
            prompt (str): User prompt
            examples (list): Optional examples for RAG
            
        Returns:
            str: ASC code
        """
        pass
        
    @abstractmethod
    def generate_chat_response(self, prompt):
        """
        Generate a chat response
        
        Args:
            prompt (str): User prompt
            
        Returns:
            str: Chat response
        """
        pass
        
    @abstractmethod
    def refine_asc_code(self, request, history):
        """
        Refine ASC code based on request and history
        
        Args:
            request (str): Original user request
            history (list): Conversation history
            
        Returns:
            str: Refined ASC code
        """
        pass
        
    @abstractmethod
    def analyze_vision_feedback(self, history, feedback, iteration):
        """
        Generate a status update based on vision feedback
        
        Args:
            history (list): Conversation history
            feedback (str): Vision feedback
            iteration (int): Current iteration
            
        Returns:
            str: Status update
        """
        pass

File: .\electroninja\llm\providers\openai.py
--------------------------------------------
import os
import openai
import logging
from electroninja.config.settings import Config
from electroninja.llm.providers.base import LLMProvider
from electroninja.llm.prompts.circuit_prompts import (
    GENERAL_INSTRUCTION,
    SAFETY_FOR_AGENT,
    REFINEMENT_PROMPT_TEMPLATE,
    VISION_ANALYSIS_PROMPT_TEMPLATE,
    CIRCUIT_RELEVANCE_EVALUATION_PROMPT,
    RAG_ASC_GENERATION_PROMPT
)
from electroninja.llm.prompts.chat_prompts import (
    CIRCUIT_CHAT_PROMPT,
    NON_CIRCUIT_CHAT_PROMPT,
    VISION_FEEDBACK_PROMPT
)
from electroninja.utils.error_handler import ModelError

logger = logging.getLogger('electroninja')

class OpenAIProvider(LLMProvider):
    """OpenAI implementation of LLM provider"""
    
    def __init__(self, config=None):
        self.config = config or Config()
        openai.api_key = self.config.OPENAI_API_KEY or os.getenv("OPENAI_API_KEY")
        self.asc_gen_model = self.config.ASC_MODEL
        self.chat_model = self.config.CHAT_MODEL
        self.evaluation_model = self.config.CHAT_MODEL  # Using same model for evaluation
        self.logger = logger
        
        if not openai.api_key:
            raise ModelError("OpenAI API key not found. Set OPENAI_API_KEY in .env file.")
    
    def evaluate_circuit_request(self, prompt):
        """
        Evaluate if a request is related to electrical circuits
        
        Args:
            prompt (str): User request to evaluate
            
        Returns:
            bool: True if circuit-related, False otherwise
        """
        try:
            evaluation_prompt = f"{GENERAL_INSTRUCTION}\n\n{CIRCUIT_RELEVANCE_EVALUATION_PROMPT.format(prompt=prompt)}"
            
            logger.info(f"Evaluating if request is circuit-related: {prompt}")
            
            response = openai.ChatCompletion.create(
                model=self.evaluation_model,
                messages=[{"role": "user", "content": evaluation_prompt}]
            )
            
            result = response.choices[0].message.content.strip()
            is_circuit_related = result.upper().startswith('Y')
            
            logger.info(f"Evaluation result for '{prompt}': {is_circuit_related}")
            return is_circuit_related
            
        except Exception as e:
            logger.error(f"Error evaluating request: {str(e)}")
            return False  # Default to not circuit-related in case of error
    
    def extract_clean_asc_code(self, asc_code):
        """
        Extract only the pure ASC code starting from 'Version 4'
        This ensures we don't include descriptions in the ASC code examples
        """
        if "Version 4" in asc_code:
            idx = asc_code.find("Version 4")
            return asc_code[idx:].strip()
        return asc_code.strip()
    
    def generate_asc_code(self, prompt, examples=None):
        """
        Generate ASC code for a circuit based on the user's prompt and optional examples
        
        Args:
            prompt (str): User's circuit request
            examples (list, optional): Similar circuit examples from vector DB
        
        Returns:
            str: Generated ASC code or 'N' if not related to circuits
        """
        # Check if the request is related to circuits using the model
        if not self.evaluate_circuit_request(prompt):
            self.logger.info(f"Request not circuit-related (model evaluation): {prompt}")
            return "N"
        
        self.logger.info(f"Generating ASC code for request: {prompt}")
        
        # Build prompt with examples if provided
        system_prompt = f"{GENERAL_INSTRUCTION}\n\n{SAFETY_FOR_AGENT}"
        user_prompt = self._build_prompt(prompt, examples)
        
        try:
            response = openai.ChatCompletion.create(
                model=self.asc_gen_model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
            )
            
            # Extract content
            asc_code = response.choices[0].message.content.strip()
            
            # Post-process to ensure only ASC code is returned
            if asc_code.upper() == "N":
                return "N"
            else:
                # Extract only the ASC code part
                return self.extract_clean_asc_code(asc_code)
                
        except Exception as e:
            self.logger.error(f"Error generating ASC code: {str(e)}")
            return "Error: Failed to generate circuit"
    
    def _build_prompt(self, request, examples=None):
        """Build a prompt with or without examples"""
        if not examples or len(examples) == 0:
            return f"User's request: {request}\n\n{RAG_ASC_GENERATION_PROMPT}"
        
        examples_text = ""
        for i, example in enumerate(examples, start=1):
            # Get description from metadata
            desc = example.get("metadata", {}).get("description", "No description")
            
            # Get ASC code, preferring pure_asc_code if available
            if "metadata" in example and "pure_asc_code" in example["metadata"]:
                asc_code = example["metadata"]["pure_asc_code"]
            else:
                # Fall back to asc_code field
                asc_code = example.get("asc_code", "")
            
            # Clean the ASC code
            asc_code = self.extract_clean_asc_code(asc_code)
            
            # Format with clear separation
            examples_text += (
                f"Example {i}:\n"
                f"Description: {desc}\n"
                f"ASC Code:\n"
                f"-----------------\n"
                f"{asc_code}\n"
                f"-----------------\n\n"
            )
        
        return (
            "Below are examples of circuits similar to the user's request:\n\n"
            f"{examples_text}"
            f"User's request: {request}\n\n"
            f"{RAG_ASC_GENERATION_PROMPT}"
        )
    
    def generate_chat_response(self, prompt):
        """Generate a chat response"""
        try:
            # Use the dedicated model evaluation
            is_circuit_related = self.evaluate_circuit_request(prompt)
            
            if is_circuit_related:
                chat_prompt = f"{GENERAL_INSTRUCTION}\n{CIRCUIT_CHAT_PROMPT.format(prompt=prompt)}"
            else:
                chat_prompt = f"{GENERAL_INSTRUCTION}\n{NON_CIRCUIT_CHAT_PROMPT.format(prompt=prompt)}"
            
            logger.info(f"Generating chat response for prompt: {prompt}")
            
            # Call OpenAI API
            response = openai.ChatCompletion.create(
                model=self.chat_model,
                messages=[{"role": "user", "content": chat_prompt}]
            )
            
            # Extract and return response
            chat_response = response.choices[0].message.content.strip()
            return chat_response
            
        except Exception as e:
            logger.error(f"Error generating chat response: {str(e)}")
            raise ModelError(f"Failed to generate chat response: {str(e)}")
    
    def generate_vision_feedback_response(self, vision_feedback):
        """
        Generate a user-friendly response based on vision model feedback
        
        Args:
            vision_feedback (str): Feedback from vision model about the circuit
            
        Returns:
            str: User-friendly response about circuit status
        """
        try:
            # Check if vision feedback is exactly 'Y' (success)
            is_success = vision_feedback.strip() == 'Y'
            
            # Build prompt based on feedback
            prompt = VISION_FEEDBACK_PROMPT.format(
                vision_feedback=vision_feedback
            )
            
            logger.info(f"Generating vision feedback response (success={is_success})")
            
            # Call OpenAI API with gpt-4o-mini
            response = openai.ChatCompletion.create(
                model=self.chat_model,  # Should be configured as gpt-4o-mini
                messages=[{"role": "user", "content": prompt}]
            )
            
            # Extract and return the response
            feedback_response = response.choices[0].message.content.strip()
            return feedback_response
            
        except Exception as e:
            logger.error(f"Error generating vision feedback response: {str(e)}")
            # Provide a default response in case of error
            if vision_feedback.strip() == 'Y':
                return "Your circuit is complete and meets the requirements. Feel free to ask if you'd like any modifications."
            else:
                return "I identified some issues with the circuit and I'm working to fix them. I'll have an improved version shortly."
    
    def refine_asc_code(self, request, history):
        """Refine ASC code based on request and history"""
        try:
            # Build refinement prompt
            prompt = "Below are previous attempts and feedback:\n\n"
            
            for item in history:
                if "asc_code" in item:
                    prompt += f"Attempt {item.get('attempt', item.get('iteration', '?'))} ASC code:\n{item['asc_code']}\n\n"
                    
                if "vision_feedback" in item:
                    prompt += f"Vision feedback (Iteration {item.get('iteration','?')}): {item['vision_feedback']}\n\n"
                    
            prompt += f"Original user's request: {request}\n\n"
            prompt += REFINEMENT_PROMPT_TEMPLATE
            
            logger.info(f"Refining ASC code based on feedback")
            
            # Call OpenAI API
            response = openai.ChatCompletion.create(
                model=self.asc_gen_model,
                messages=[{"role": "system", "content": GENERAL_INSTRUCTION},
                          {"role": "user", "content": prompt}]
            )
            
            # Extract and return refined ASC code
            refined_asc = response.choices[0].message.content.strip()
            return refined_asc
            
        except Exception as e:
            logger.error(f"Error refining ASC code: {str(e)}")
            raise ModelError(f"Failed to refine ASC code: {str(e)}")
    
    def analyze_vision_feedback(self, history, feedback, iteration):
        """Generate a status update based on vision feedback"""
        try:
            prompt = (
                VISION_ANALYSIS_PROMPT_TEMPLATE +
                "\n\nConversation History:\n"
            )
            
            for item in history:
                prompt += f"{item}\n"
                
            prompt += f"\nLatest Vision Feedback (Iteration {iteration}): {feedback}\n"
            prompt += "Status update:"
            
            logger.info(f"Generating status update for iteration {iteration}")
            
            response = openai.ChatCompletion.create(
                model=self.chat_model,
                messages=[{"role": "user", "content": prompt}],
            )
            
            # Extract and return status update
            status_update = response.choices[0].message.content.strip()
            return status_update
            
        except Exception as e:
            logger.error(f"Error generating status update: {str(e)}")
            raise ModelError(f"Failed to generate status update: {str(e)}")

File: .\electroninja\llm\providers\__init__.py
----------------------------------------------
from electroninja.llm.providers.base import LLMProvider
from electroninja.llm.providers.openai import OpenAIProvider

__all__ = ['LLMProvider', 'OpenAIProvider']

File: .\electroninja\ui\main_window.py
--------------------------------------
# main_window.py

import logging
import os
from PyQt5.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QMessageBox, QApplication
from PyQt5.QtCore import Qt, QPropertyAnimation, QEasingCurve, pyqtSlot
from electroninja.config.settings import Config
from electroninja.core.circuit_processor import CircuitProcessor
from electroninja.utils.async_workers import CircuitProcessingWorker
from electroninja.utils.error_handler import handle_error
from electroninja.utils.file_operations import save_file
from electroninja.ui.panels.left_panel import LeftPanel
from electroninja.ui.panels.middle_panel import MiddlePanel
from electroninja.ui.panels.right_panel import RightPanel
from electroninja.ui.components.top_bar import TopBar
from electroninja.ui.styles import STYLE_SHEET, setup_fonts

logger = logging.getLogger('electroninja')

class MainWindow(QMainWindow):
    """Main application window for ElectroNinja"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ElectroNinja - Electrical Engineer Agent")
        self.setGeometry(100, 50, 1400, 800)
        
        # Initialize configuration
        self.config = Config()
        
        # Initialize circuit processor
        self.circuit_processor = CircuitProcessor(self.config)
        
        # Panel widths
        self.left_panel_collapsed_width = 80
        self.left_panel_expanded_width = 300
        
        # Current file path
        self.current_circuit_file = None
        
        # Initialize UI
        self.init_ui()
        self.connect_signals()
        self.adjust_panel_widths()
        
    def init_ui(self):
        """Initialize the UI components"""
        # Set up fonts - use QApplication.instance() instead of self.app()
        setup_fonts(QApplication.instance())
        
        # Apply stylesheet
        self.setStyleSheet(STYLE_SHEET)
        
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)
        
        # Add top bar
        self.top_bar = TopBar(self)
        main_layout.addWidget(self.top_bar)
        
        # Create panels layout
        self.panels_layout = QHBoxLayout()
        self.panels_layout.setSpacing(10)
        main_layout.addLayout(self.panels_layout)
        
        # Create panels
        self.left_panel = LeftPanel(self)
        self.middle_panel = MiddlePanel(self)
        self.right_panel = RightPanel(self)
        
        # Configure left panel
        self.left_panel.setMinimumWidth(self.left_panel_collapsed_width)
        self.left_panel.setMaximumWidth(300)
        
        # Add panels to layout
        self.panels_layout.addWidget(self.left_panel)
        self.panels_layout.addWidget(self.middle_panel)
        self.panels_layout.addWidget(self.right_panel)
        
        logger.info("UI initialized")
        
    def connect_signals(self):
        """Connect signals between components"""
        # Left panel signals
        self.left_panel.toggleRequested.connect(self.on_left_panel_toggle)
        self.left_panel.compile_button.clicked.connect(self.compile_circuit)
        
        # Middle panel signals
        self.middle_panel.editRequested.connect(self.edit_with_ltspice)
        
        # Right panel signals
        self.right_panel.messageSent.connect(self.handle_message)
        
        logger.info("Signals connected")
        
    def on_left_panel_toggle(self, is_expanding):
        """Handle left panel toggle button click"""
        logger.info(f"Left panel toggle: {'expand' if is_expanding else 'collapse'}")
        
        if is_expanding:
            current_width = self.left_panel.width()
            self.left_panel.showCodeEditor()
            self.animate_left_panel(current_width, self.left_panel_expanded_width)
        else:
            current_width = self.left_panel.width()
            self.animate_left_panel(current_width, self.left_panel_collapsed_width)
            self.left_panel.hideCodeEditor()
            
    def animate_left_panel(self, start_width, end_width):
        """Animate the left panel width change"""
        animation = QPropertyAnimation(self.left_panel, b"maximumWidth")
        animation.setDuration(600)
        animation.setStartValue(start_width)
        animation.setEndValue(end_width)
        animation.setEasingCurve(QEasingCurve.OutCubic)
        animation.start()
        
    def adjust_panel_widths(self):
        """Adjust panel widths based on window size"""
        total_width = self.width() - 40
        left_width = int(total_width * 0.22)
        right_width = int(total_width * 0.28)
        
        self.left_panel_expanded_width = left_width
        
        if self.left_panel.is_expanded:
            self.left_panel.setMaximumWidth(left_width)
        else:
            self.left_panel.setMaximumWidth(self.left_panel_collapsed_width)
            
        self.right_panel.setFixedWidth(right_width)
        
        logger.info(f"Adjusted panel widths: Left={left_width}, Right={right_width}")
        
    def resizeEvent(self, event):
        """Handle window resize events"""
        super().resizeEvent(event)
        self.adjust_panel_widths()
        
    @pyqtSlot(str)
    def handle_message(self, message):
        """Handle incoming chat messages"""
        logger.info(f"Handling message: {message[:50]}...")
        
        # Check if this is a circuit request
        if self.circuit_processor.is_circuit_request(message):
            # Process as circuit request
            self.process_circuit_request(message)
        else:
            # Generate simple response
            response = self.generate_chat_response(message)
            self.right_panel.receive_message(response)
            
    def process_circuit_request(self, request):
        """Process a circuit design request"""
        logger.info(f"Processing circuit request: {request}")
        
        # Initial response
        self.right_panel.receive_message(
            "I'll design this circuit for you. Starting the design process..."
        )
        
        # Create worker thread for processing
        self.worker = CircuitProcessingWorker(
            self.circuit_processor.feedback_manager,
            request
        )
        
        # Connect signals
        self.worker.statusUpdate.connect(self.right_panel.receive_message)
        self.worker.resultReady.connect(self.handle_circuit_result)
        
        # Start processing
        self.worker.start()
        
    def handle_circuit_result(self, result):
        """Handle circuit processing result"""
        if result.get("success", False):
            # Update UI with successful circuit
            self.left_panel.set_code(result["asc_code"])
            self.middle_panel.set_circuit_image(result["image_path"])
            self.current_circuit_file = result.get("asc_path")
            
            # Success message
            self.right_panel.receive_message(
                f"Circuit successfully verified after {result['iterations']} iterations!"
            )
        else:
            # Handle failure
            if "error" in result:
                self.right_panel.receive_message(
                    f"Error processing circuit: {result['error']}"
                )
            else:
                self.right_panel.receive_message(
                    f"Could not verify circuit after {result['iterations']} iterations. "
                    "The best attempt is shown."
                )
                
                # Still update UI with best attempt
                if "asc_code" in result:
                    self.left_panel.set_code(result["asc_code"])
                if "image_path" in result:
                    self.middle_panel.set_circuit_image(result["image_path"])
                    
            logger.error(f"Circuit processing failed: {result.get('error', 'Unknown error')}")
            
    def compile_circuit(self):
        """Manually compile the current circuit"""
        logger.info("Manual circuit compilation requested")
        
        # Get code from editor
        asc_code = self.left_panel.get_code()
        
        if not asc_code.strip():
            QMessageBox.warning(self, "Error", "Please enter circuit code first!")
            return
            
        # Save to file
        if not self.current_circuit_file:
            self.current_circuit_file = os.path.join(self.config.OUTPUT_DIR, "circuit.asc")
            
        try:
            save_file(asc_code, self.current_circuit_file)
            
            # Process circuit
            self.right_panel.receive_message("Processing circuit...")
            
            result = self.circuit_processor.manual_circuit_processing(
                asc_code,
                status_callback=self.right_panel.receive_message
            )
            
            if result.get("success", False):
                self.middle_panel.set_circuit_image(result["image_path"])
                self.right_panel.receive_message("Circuit compiled successfully!")
            else:
                self.right_panel.receive_message(f"Error: {result.get('error', 'Unknown error')}")
                
        except Exception as e:
            error_message = handle_error(e, self, "Failed to compile circuit")
            self.right_panel.receive_message(f"Error: {error_message}")
            
    def edit_with_ltspice(self):
        """Edit circuit in LTSpice"""
        logger.info("Edit with LTSpice requested")
        
        # Get code from editor
        asc_code = self.left_panel.get_code()
        
        if not asc_code.strip():
            QMessageBox.warning(self, "Error", "Please enter circuit code first!")
            return
            
        # Save to file
        if not self.current_circuit_file:
            self.current_circuit_file = os.path.join(self.config.OUTPUT_DIR, "circuit.asc")
            
        try:
            save_file(asc_code, self.current_circuit_file)
            
            # Process circuit with LTSpice
            self.right_panel.receive_message("Opening circuit in LTSpice...")
            
            result = self.circuit_processor.ltspice.process_circuit(
                self.current_circuit_file,
                new_window=True
            )
            
            if result:
                updated_asc_path, image_path = result
                
                # Update UI
                with open(updated_asc_path, "r", encoding="utf-8", errors="replace") as f:
                    updated_code = f.read()
                    
                self.left_panel.set_code(updated_code)
                self.middle_panel.set_circuit_image(image_path)
                self.right_panel.receive_message("Circuit updated from LTSpice!")
                
        except Exception as e:
            error_message = handle_error(e, self, "Failed to edit with LTSpice")
            self.right_panel.receive_message(f"Error: {error_message}")
            


File: .\electroninja\ui\signals.py
----------------------------------
"""Custom signals for ElectroNinja application"""
from PyQt5.QtCore import QObject, pyqtSignal

class CircuitSignals(QObject):
    """Signals related to circuit processing"""
    
    # Signal emitted when a circuit processing begins
    processingStarted = pyqtSignal(str)  # Message
    
    # Signal emitted when a circuit processing completes
    processingComplete = pyqtSignal(bool, str, str)  # Success, asc_path, image_path
    
    # Signal emitted for status updates during processing
    statusUpdate = pyqtSignal(str)  # Status message
    
    # Signal emitted when an error occurs
    errorOccurred = pyqtSignal(str)  # Error message

class ChatSignals(QObject):
    """Signals related to chat interactions"""
    
    # Signal emitted when a message is sent by the user
    messageSent = pyqtSignal(str)  # Message text
    
    # Signal emitted when a response is received
    responseReceived = pyqtSignal(str)  # Response text

File: .\electroninja\ui\styles.py
---------------------------------
"""Styling for the ElectroNinja application"""

# Define color palette - dark theme with purple accent
COLORS = {
    'background': '#1E1E1E',      # Main background
    'panel_bg': '#2F2F2F',        # Panel background
    'chat_bg': '#252526',         # Chat background (dark instead of white)
    'text_primary': '#FFFFFF',    # Primary text color
    'text_secondary': '#B0B0B0',  # Secondary text color
    'accent_purple': '#4B2F4C',   # Dark purple accent
    'accent_purple_light': '#5F3D61', # Light purple for hover states
    'border': '#3C3C3C',          # Border color
    'input_bg': '#2B2B2B',        # Input background
    'button_bg': '#4B2F4C',       # Button background (now purple)
    'button_hover': '#5F3D61'     # Button hover (lighter purple)
}

STYLE_SHEET = f"""
QMainWindow, QDialog {{
    background-color: {COLORS['background']};
}}

/* Rounded, darker frames */
QFrame {{
    background-color: {COLORS['panel_bg']};
    border-radius: 12px;
    border: 1px solid {COLORS['border']};
}}

/* Text labels */
QLabel {{
    color: {COLORS['text_primary']};
    font-family: 'Segoe UI', sans-serif;
}}

/* Text editors (code/chat) */
QTextEdit {{
    background-color: {COLORS['input_bg']};
    color: {COLORS['text_primary']};
    border: 1px solid {COLORS['border']};
    border-radius: 8px;
    font-family: 'Consolas', monospace;
    font-size: 16px;
    padding: 8px;
    selection-background-color: {COLORS['accent_purple']}80; /* 50% opacity */
}}

/* Scrollbars for TextEdit */
QTextEdit QScrollBar:vertical {{
    background-color: {COLORS['input_bg']};
    width: 12px;
    border-radius: 6px;
}}

QTextEdit QScrollBar::handle:vertical {{
    background-color: {COLORS['accent_purple']};
    border-radius: 6px;
    min-height: 20px;
}}

QTextEdit QScrollBar::add-line:vertical, 
QTextEdit QScrollBar::sub-line:vertical {{
    height: 0px;
}}

/* Single-line input */
QLineEdit {{
    background-color: {COLORS['input_bg']};
    color: {COLORS['text_primary']};
    border: 1px solid {COLORS['border']};
    border-radius: 8px;
    font-family: 'Segoe UI', sans-serif;
    font-size: 16px;
    padding: 8px 12px;
    selection-background-color: {COLORS['accent_purple']}80;
}}

/* General buttons */
QPushButton {{
    background-color: {COLORS['button_bg']};
    color: {COLORS['text_primary']};
    border-radius: 5px;
    border: none;
    padding: 10px 15px;
    font-family: 'Segoe UI', sans-serif;
    font-size: 16px;
}}

/* Hover effect with a light purple accent */
QPushButton:hover {{
    background-color: {COLORS['button_hover']};
}}

QPushButton:pressed {{
    background-color: {COLORS['accent_purple']};
}}

/* Tool buttons (toggle arrow) */
QToolButton {{
    background-color: {COLORS['accent_purple']};
    color: {COLORS['text_primary']};
    border-radius: 8px;
    border: none;
    padding: 10px;
    font-family: 'Segoe UI', sans-serif;
    font-size: 16px;
}}

QToolButton:hover {{
    background-color: {COLORS['accent_purple_light']};
}}

QToolButton:pressed {{
    background-color: #7D3C98;
}}

/* Circuit title styling */
#circuit_title {{
    font-family: 'Segoe UI', sans-serif;
    font-size: 40px;
    font-weight: bold;
    color: {COLORS['text_primary']};
}}

/* Panel titles */
.panel_title {{
    font-family: 'Segoe UI', sans-serif;
    font-size: 20px;
    font-weight: bold;
    color: {COLORS['text_primary']};
}}

/* Top bar styling */
#top_bar {{
    background: qlineargradient(x1:0, y1:0, x2:1, y2:0, 
                               stop:0 #8E44AD, stop:1 #9B59B6);
    border-radius: 12px;
    padding: 5px;
}}

/* Top bar title */
#app_title {{
    font-family: 'Segoe UI', sans-serif;
    font-size: 32px;
    font-weight: bold;
    color: white;
    padding: 5px;
}}

/* Button styling - using consistent colors */
#compile_button {{
    background-color: {COLORS['button_bg']};
}}

#compile_button:hover {{
    background-color: {COLORS['button_hover']};
}}

#edit_button {{
    background-color: {COLORS['button_bg']};
    font-size: 18px;
    padding: 10px 20px;
}}

#edit_button:hover {{
    background-color: {COLORS['button_hover']};
}}

#send_button {{
    background-color: {COLORS['accent_purple']};
    border-radius: 8px;
}}

/* Placeholder for circuit display */
#circuit_display {{
    background-color: {COLORS['input_bg']};
    color: {COLORS['text_secondary']};
    border: 2px dashed {COLORS['border']};
    border-radius: 10px;
    font-size: 20px;
}}
"""

def setup_fonts(app):
    """Setup custom fonts if needed"""
    from PyQt5.QtGui import QFontDatabase
    # Add local font files here if desired
    pass

File: .\electroninja\ui\__init__.py
-----------------------------------
from electroninja.ui.main_window import MainWindow
from electroninja.ui.styles import STYLE_SHEET, setup_fonts

__all__ = ['MainWindow', 'STYLE_SHEET', 'setup_fonts']

File: .\electroninja\ui\components\chat_bubble.py
-------------------------------------------------
# chat_bubble.py


import logging
from PyQt5.QtWidgets import (
    QFrame, QVBoxLayout, QTextEdit, QSizePolicy
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QFont, QTextOption

logger = logging.getLogger('electroninja')

class ChatBubble(QFrame):
    """
    A single chat message "bubble" that is only as tall as it needs
    to display the text, plus a small padding to avoid scrollbars.
    """
    def __init__(self, message, is_user=True, parent=None):
        super().__init__(parent)
        self.is_user = is_user
        self.message = message
        self.initUI(message)
        
    def initUI(self, message):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(6, 4, 6, 4)
        layout.setSpacing(0)
        
        # Bubble background color
        if self.is_user:
            self.setStyleSheet("""
                background-color: #4B2F4C;
                border-radius: 6px;
                color: white;
                border: none;
            """)
        else:
            self.setStyleSheet("""
                background-color: #333333;
                border-radius: 6px;
                color: white;
                border: none;
            """)
            
        # QTextEdit for displaying the message
        self.message_text = QTextEdit(self)
        self.message_text.setPlainText(message)
        self.message_text.setReadOnly(True)
        
        # No scrollbars so the bubble grows vertically
        self.message_text.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.message_text.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.message_text.setFrameStyle(QFrame.NoFrame)
        self.message_text.setTextInteractionFlags(Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard)
        self.message_text.setWordWrapMode(QTextOption.WrapAtWordBoundaryOrAnywhere)
        self.message_text.document().setDocumentMargin(1)
        
        # Minimal styling
        self.message_text.setStyleSheet("""
            background-color: transparent;
            color: white;
            border: none;
            padding: 0px;
            margin: 0px;
        """)
        self.message_text.setFont(QFont("Segoe UI", 12))
        
        # We'll manually set width & height in updateSize
        self.message_text.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        
        layout.addWidget(self.message_text)
        
    def showEvent(self, event):
        """
        Once this bubble is actually shown in the UI,
        we schedule a second sizing pass to see the final layout width.
        """
        super().showEvent(event)
        QTimer.singleShot(0, self._delayedSizeAdjust)
        
    def _delayedSizeAdjust(self):
        """Called via QTimer once the bubble is actually displayed."""
        if not self.parent():
            return
            
        # 1) Measure the text's natural (unwrapped) width
        doc = self.message_text.document()
        doc.setTextWidth(999999)  # no wrapping
        natural_width = doc.size().width()
        
        # 2) Determine how much horizontal space is available
        parent_width = self.parent().width()
        available_width = parent_width - 20  # e.g., 20 px margin from edges
        
        # 3) We'll use the smaller of 'natural_width' or 'available_width'
        final_width = min(natural_width, available_width)
        
        # 4) Enforce a minimal width to avoid extremely skinny bubbles
        if final_width < 30:
            final_width = 30
            
        # 5) Call updateSize() to wrap the text at 'final_width'
        self.updateSize(final_width)
        
    def updateSize(self, max_width):
        """
        Fit the text within a maximum width, but allow short messages
        to use a narrower bubble. Also adds minimal vertical padding.
        """
        doc = self.message_text.document()
        
        # Step 1: Let the document measure its natural width (no wrapping yet).
        doc.setTextWidth(999999)
        natural_width = doc.size().width()
        
        # Step 2: Clamp the width between a minimum and max_width.
        min_width = 30
        final_width = min(natural_width, max_width)
        if final_width < min_width:
            final_width = min_width
            
        # Step 3: Apply wrapping at 'final_width' and measure height.
        doc.setTextWidth(final_width)
        doc_height = doc.size().height()
        
        # Step 4: Add a small vertical padding to avoid scrollbars.
        doc_height += 5
        
        # Step 5: Update the QTextEdit size.
        self.message_text.setFixedWidth(int(final_width))
        self.message_text.setFixedHeight(int(doc_height))
        
        # Step 6: Resize the outer QFrame (the bubble).
        self.adjustSize()

File: .\electroninja\ui\components\chat_input.py
------------------------------------------------
#chat_input.py

import logging
from PyQt5.QtWidgets import (
    QWidget, QTextEdit, QPushButton, QHBoxLayout, QVBoxLayout
)
from PyQt5.QtCore import pyqtSignal, Qt, QEvent
from PyQt5.QtGui import QFontMetrics

logger = logging.getLogger('electroninja')

class AutoResizingTextEdit(QTextEdit):
    """Text edit that automatically resizes based on content"""
    
    def __init__(self, max_lines=5, min_height=40, parent=None):
        """
        min_height: should match the send button height.
        max_lines: maximum number of lines to expand to before scrolling.
        """
        super().__init__(parent)
        self.max_lines = max_lines
        self.min_height = min_height
        
        # Set a small document margin for better measurement
        self.document().setDocumentMargin(2)
        
        # Connect signals
        self.textChanged.connect(self.updateHeight)
        
        # Configuration
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        # Initial height update
        self.updateHeight()
        
    def updateHeight(self):
        """Update height based on content"""
        # Compute the desired height from the document size
        doc_height = self.document().documentLayout().documentSize().height()
        fm = self.fontMetrics()
        line_height = fm.lineSpacing()
        max_height = line_height * self.max_lines + 10  # 10px for padding
        
        # Calculate new height
        new_height = doc_height + 10  # add padding
        
        # Apply constraints
        if new_height < self.min_height:
            new_height = self.min_height
            
        if new_height > max_height:
            new_height = max_height
            self.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        else:
            self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            
        # Set new height
        self.setFixedHeight(int(new_height))

class ChatInputWidget(QWidget):
    """Widget for chat input with send button"""
    
    sendMessage = pyqtSignal(str)
    
    def __init__(self, max_lines=5, parent=None):
        super().__init__(parent)
        self.max_lines = max_lines
        self.initUI()
        
    def initUI(self):
        # Set minimum height
        self.setMinimumHeight(40)
        
        # Create layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        layout.setAlignment(Qt.AlignBottom)
        
        # Create a container to hold the text edit
        text_container = QWidget()
        text_layout = QVBoxLayout(text_container)
        text_layout.setContentsMargins(0, 0, 0, 0)
        text_layout.setSpacing(0)
        text_layout.setAlignment(Qt.AlignBottom)
        
        # Create text edit
        self.message_input = AutoResizingTextEdit(
            max_lines=self.max_lines,
            min_height=40  # Matches the send button's fixed height
        )
        self.message_input.setPlaceholderText("Type your message...")
        self.message_input.setStyleSheet("""
            background-color: #2B2B2B;
            color: white;
            border: 1px solid #3C3C3C;
            border-radius: 8px;
            padding: 8px;
        """)
        
        # Add text edit to container
        text_layout.addWidget(self.message_input, alignment=Qt.AlignBottom)
        
        # Add container to layout
        layout.addWidget(text_container, 1)
        
        # Create send button
        self.send_button = QPushButton("Send", self)
        self.send_button.setFixedSize(70, 40)
        self.send_button.setObjectName("send_button")
        
        # Add send button to layout
        layout.addWidget(self.send_button, 0, alignment=Qt.AlignBottom)
        
        # Connect signals
        self.send_button.clicked.connect(self.onSendClicked)
        self.message_input.installEventFilter(self)
        
    def eventFilter(self, obj, event):
        """Filter events to capture enter key"""
        if obj is self.message_input and event.type() == QEvent.KeyPress:
            # Allow Shift+Enter to insert a newline; plain Enter triggers send.
            if event.key() == Qt.Key_Return and not (event.modifiers() & Qt.ShiftModifier):
                self.onSendClicked()
                return True
        return super().eventFilter(obj, event)
        
    def onSendClicked(self):
        """Handle send button click or Enter key"""
        text = self.message_input.toPlainText().strip()
        if text:
            self.sendMessage.emit(text)
            self.message_input.clear()

File: .\electroninja\ui\components\chat_panel.py
------------------------------------------------
# chat_panel.py

import logging
from PyQt5.QtWidgets import (
    QScrollArea, QWidget, QVBoxLayout, QHBoxLayout, QSizePolicy
)
from PyQt5.QtCore import Qt, QPropertyAnimation, QEasingCurve, QTimer
from PyQt5.QtGui import QFont
from electroninja.ui.components.chat_bubble import ChatBubble

logger = logging.getLogger('electroninja')

class ChatPanel(QScrollArea):
    """
    A scrollable container for all chat bubbles (both user and assistant).
    Manages bubble widths to prioritize horizontal expansion.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.bubbles = []
        self.bubble_containers = []
        self.initUI()
        
    def initUI(self):
        # Container widget for all chat bubbles
        self.chat_container = QWidget()
        self.chat_container.setStyleSheet("background-color: #252526;")
        
        # Set size policy to allow expansion
        self.chat_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        # Vertical layout for the bubbles
        self.chat_layout = QVBoxLayout(self.chat_container)
        self.chat_layout.setSpacing(3)  # Reduced spacing between messages
        self.chat_layout.setContentsMargins(1, 1, 1, 1)  # Reduced margins
        self.chat_layout.setAlignment(Qt.AlignTop)
        
        # Add a stretch at the end so the bubbles "stick" to the top
        self.chat_layout.addStretch()
        
        # Configure the QScrollArea
        self.setWidget(self.chat_container)
        self.setWidgetResizable(True)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.setStyleSheet("background-color: #252526; border: none;")
        
    def add_message(self, message, is_user=True):
        """
        Add a new bubble to the chat, either aligned left (assistant)
        or aligned right (user).
        """
        # Log message
        logger.info(f"Adding message to chat panel: {'User' if is_user else 'Assistant'}")
        
        # Remove the final stretch temporarily
        if self.chat_layout.count() > 0:
            self.chat_layout.removeItem(self.chat_layout.itemAt(self.chat_layout.count() - 1))
            
        # Create a container for the bubble + horizontal layout
        container = QWidget()
        container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)
        h_layout = QHBoxLayout(container)
        h_layout.setContentsMargins(0, 0, 0, 0)
        h_layout.setSpacing(0)
        
        # Calculate max bubble width as percentage of viewport
        viewport_width = self.viewport().width()
        # Allow more horizontal space - both message types should expand well horizontally
        # Machine messages can be wider than user messages
        max_width = int(viewport_width * (0.85 if is_user else 0.90))
        
        # Create the bubble
        bubble = ChatBubble(message, is_user, container)
        self.bubbles.append(bubble)
        self.bubble_containers.append(container)
        
        # Align the bubble: right for user, left for assistant
        if is_user:
            h_layout.addStretch(1)  # Push to the right
            h_layout.addWidget(bubble, 0, Qt.AlignRight)
        else:
            h_layout.addWidget(bubble, 0, Qt.AlignLeft)
            h_layout.addStretch(1)  # Push to the left
            
        # Set width limits and apply
        bubble.updateSize(max_width)
        
        # Force container to size properly to its contents
        container.adjustSize()
        
        # Add the container to the main chat layout
        self.chat_layout.addWidget(container)
        
        # Re-add the stretch at the bottom
        self.chat_layout.addStretch()
        
        # Use a small delay to ensure all layouts are updated before scrolling
        QTimer.singleShot(50, self.smooth_scroll_to_bottom)
        
        # Return the created bubble (useful for further manipulation)
        return bubble
        
    def smooth_scroll_to_bottom(self):
        """Smoothly scroll to the bottom of the chat."""
        current_pos = self.verticalScrollBar().value()
        max_pos = self.verticalScrollBar().maximum()
        
        if current_pos < max_pos:
            self.scroll_animation = QPropertyAnimation(self.verticalScrollBar(), b"value")
            self.scroll_animation.setDuration(300)
            self.scroll_animation.setStartValue(current_pos)
            self.scroll_animation.setEndValue(max_pos)
            self.scroll_animation.setEasingCurve(QEasingCurve.OutCubic)
            self.scroll_animation.start()
        else:
            # Already at the bottom, just ensure we're exactly at the max
            self.verticalScrollBar().setValue(max_pos)
            
    def resizeEvent(self, event):
        """
        When the chat panel is resized, update all bubbles to ensure proper width.
        This allows messages to expand or contract horizontally based on available space.
        """
        super().resizeEvent(event)
        viewport_width = self.viewport().width()
        
        # Update each bubble's width limits
        for i, bubble in enumerate(self.bubbles):
            # Calculate appropriate width (allow more horizontal space)
            if bubble.is_user:
                max_width = int(viewport_width * 0.85)
            else:
                max_width = int(viewport_width * 0.90)
                
            # Update the bubble size with new constraints
            bubble.updateSize(max_width)
            
    def clear_chat(self):
        """
        Remove all chat bubbles from the layout.
        """
        self.bubbles.clear()
        self.bubble_containers.clear()
        
        # Remove all widgets except the final stretch
        while self.chat_layout.count() > 1:
            item = self.chat_layout.itemAt(0)
            if item.widget():
                item.widget().deleteLater()
            self.chat_layout.removeItem(item)
            
        # Ensure we have that final stretch
        if self.chat_layout.count() == 0:
            self.chat_layout.addStretch()

File: .\electroninja\ui\components\top_bar.py
---------------------------------------------
# top_bar.py

import logging
from PyQt5.QtWidgets import QFrame, QHBoxLayout, QLabel, QSizePolicy
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont

logger = logging.getLogger('electroninja')

class TopBar(QFrame):
    """Top bar with application title"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("top_bar")
        self.initUI()
        
    def initUI(self):
        # Styling
        self.setStyleSheet("""
            background-color: #4B2F4C; 
            border-radius: 10px; 
            border: none;
        """)
        
        # Layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(20, 10, 20, 10)
        
        # Center the title with stretchers
        layout.addStretch(1)
        
        # ElectroNinja title
        self.title = QLabel("ElectroNinja", self)
        
        # Set font
        font = QFont("Segoe UI", 28)
        font.setBold(True)
        font.setWeight(75)
        self.title.setFont(font)
        
        # Styling
        self.title.setStyleSheet("""
            color: white; 
            background: transparent; 
            padding: 2px; 
            margin: 0px;
        """)
        
        # Alignment
        self.title.setAlignment(Qt.AlignCenter)
        self.title.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        
        # Add to layout
        layout.addWidget(self.title)
        layout.addStretch(1)
        
        # Version label
        self.version_label = QLabel("v1.0", self)
        self.version_label.setStyleSheet("color: white; font-size: 14px; background: transparent;")
        self.version_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        layout.addWidget(self.version_label)
        
        # Size constraints
        self.setMinimumHeight(80)
        self.setMaximumHeight(80)

File: .\electroninja\ui\components\__init__.py
----------------------------------------------
from electroninja.ui.components.chat_bubble import ChatBubble
from electroninja.ui.components.chat_input import ChatInputWidget, AutoResizingTextEdit
from electroninja.ui.components.chat_panel import ChatPanel
from electroninja.ui.components.top_bar import TopBar

__all__ = ['ChatBubble', 'ChatInputWidget', 'AutoResizingTextEdit', 'ChatPanel', 'TopBar']

File: .\electroninja\ui\panels\left_panel.py
--------------------------------------------
# left_panel.py


import logging
from PyQt5.QtWidgets import (
    QFrame, QVBoxLayout, QLabel, QToolButton, QTextEdit, 
    QPushButton, QHBoxLayout, QSizePolicy
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QFont
from electroninja.config.settings import Config

logger = logging.getLogger('electroninja')

class LeftPanel(QFrame):
    """Left panel for ASC code editing"""
    
    toggleRequested = pyqtSignal(bool)
    imageGenerated = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.config = Config()
        self.is_expanded = True
        self.initUI()
        
    def initUI(self):
        self.setMinimumWidth(80)
        
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)
        
        # Header layout
        header_layout = QHBoxLayout()
        
        self.asc_title = QLabel(".asc File", self)
        self.asc_title.setStyleSheet("font-size: 18px; font-weight: bold; color: white;")
        self.asc_title.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        header_layout.addWidget(self.asc_title)
        
        header_layout.addStretch()
        
        # Toggle button
        self.toggle_button = QToolButton(self)
        self.toggle_button.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        self.toggle_button.setArrowType(Qt.LeftArrow)
        self.toggle_button.setText("Hide")
        self.toggle_button.setCheckable(True)
        self.toggle_button.setChecked(True)
        self.toggle_button.clicked.connect(self.on_toggle_clicked)
        header_layout.addWidget(self.toggle_button)
        
        main_layout.addLayout(header_layout)
        
        # Code editor
        self.code_editor = QTextEdit(self)
        self.code_editor.setPlaceholderText("Enter .asc code here...")
        self.code_editor.setFont(QFont("Consolas", 13))
        main_layout.addWidget(self.code_editor)
        
        # Compile button
        self.compile_button = QPushButton("Compile Circuit", self)
        self.compile_button.setObjectName("compile_button")
        main_layout.addWidget(self.compile_button)
        
    def on_toggle_clicked(self):
        is_checked = self.toggle_button.isChecked()
        self.is_expanded = is_checked
        self.toggleRequested.emit(is_checked)
        self.toggle_button.setArrowType(Qt.LeftArrow if is_checked else Qt.RightArrow)
        self.toggle_button.setText("Hide" if is_checked else "Show")
        
    def showCodeEditor(self):
        self.code_editor.show()
        
    def hideCodeEditor(self):
        self.code_editor.hide()
        
    def get_code(self):
        """Get the current code from the editor"""
        return self.code_editor.toPlainText()
        
    def set_code(self, code):
        """Set the code in the editor"""
        self.code_editor.setText(code)

File: .\electroninja\ui\panels\middle_panel.py
----------------------------------------------
#middle_panel.py


import os
import logging
from PyQt5.QtWidgets import (
    QFrame, QVBoxLayout, QLabel, QPushButton, QSizePolicy,
    QHBoxLayout, QWidget, QMessageBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QFont, QPixmap
from electroninja.config.settings import Config

logger = logging.getLogger('electroninja')

class MiddlePanel(QFrame):
    """Middle panel for circuit visualization"""
    
    editRequested = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.config = Config()
        self.current_image_path = None
        self.initUI()
        
    def initUI(self):
        # Main layout for the middle panel
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(15, 15, 15, 15)
        self.main_layout.setSpacing(15)
        
        # Header with "Current Circuit" title
        self.circuit_title = QLabel("Current Circuit", self)
        self.circuit_title.setStyleSheet(
            "font-size: 36px; font-weight: bold; color: white; letter-spacing: 1px; background: transparent;"
        )
        self.circuit_title.setAlignment(Qt.AlignCenter)
        self.main_layout.addWidget(self.circuit_title)
        
        # Container for the square display with center alignment
        self.display_container = QWidget()
        display_layout = QVBoxLayout(self.display_container)
        display_layout.setContentsMargins(20, 20, 20, 20)
        
        # Add horizontal layout to center the square
        h_layout = QHBoxLayout()
        h_layout.setAlignment(Qt.AlignCenter)
        
        # The frame that will be kept square
        self.display_frame = QFrame()
        self.display_frame.setStyleSheet("""
            background-color: #2B2B2B;
            border: 1px dashed #5A5A5A;
            border-radius: 5px;
        """)
        
        # Start with a reasonable size
        self.display_frame.setMinimumSize(400, 400)
        
        # Layout for the placeholder text
        frame_layout = QVBoxLayout(self.display_frame)
        frame_layout.setAlignment(Qt.AlignCenter)
        
        # Placeholder text
        self.circuit_display = QLabel("Circuit Screenshot Placeholder")
        self.circuit_display.setAlignment(Qt.AlignCenter)
        self.circuit_display.setStyleSheet("border: none; color: #AAAAAA;")
        self.circuit_display.setFont(QFont("Segoe UI", 16))
        self.circuit_display.setWordWrap(True)
        
        # An image label that will actually show the PNG
        self.image_label = QLabel(self.display_frame)
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setStyleSheet("border: none; color: #AAAAAA;")
        
        frame_layout.addWidget(self.image_label)
        frame_layout.addWidget(self.circuit_display)
        h_layout.addWidget(self.display_frame)
        display_layout.addLayout(h_layout)
        
        # Add to main layout
        self.main_layout.addWidget(self.display_container)
        
        # "Edit with LT Spice" button
        buttons_layout = QHBoxLayout()
        self.edit_button = QPushButton("Edit with LT Spice", self)
        self.edit_button.setObjectName("edit_button")
        self.edit_button.clicked.connect(self.on_edit_clicked)
        
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.edit_button)
        buttons_layout.addStretch()
        
        self.main_layout.addLayout(buttons_layout)
        
        # Add a stretcher at the bottom
        self.main_layout.addStretch()
        
    def set_circuit_image(self, image_path):
        """Update the image display with a new circuit image"""
        logger.info(f"Setting circuit image: {image_path}")
        self.current_image_path = image_path
        
        pixmap = QPixmap(image_path)
        if pixmap.isNull():
            logger.error(f"Failed to load image: {image_path}")
            self.image_label.setText("Failed to load image")
            self.circuit_display.setText("Circuit Screenshot Placeholder")
        else:
            # Hide placeholder text, show the image
            self.circuit_display.setText("")
            self.image_label.setPixmap(pixmap.scaled(
                400, 400, 
                Qt.KeepAspectRatio, 
                Qt.SmoothTransformation
            ))
            
    def on_edit_clicked(self):
        """Request to edit the circuit in LTSpice"""
        self.editRequested.emit()
        
    def resizeEvent(self, event):
        """Handle resize to maintain square display frame"""
        super().resizeEvent(event)
        
        # Calculate the square size based on available space
        available_width = self.width() - 100
        available_height = self.height() - 200
        square_size = min(available_width, available_height)
        
        if square_size > 0:
            self.display_frame.setFixedSize(square_size, square_size)
            
            # If an image is set, rescale it
            if self.current_image_path and os.path.exists(self.current_image_path):
                pixmap = QPixmap(self.current_image_path)
                if not pixmap.isNull():
                    self.image_label.setPixmap(pixmap.scaled(
                        square_size, 
                        square_size, 
                        Qt.KeepAspectRatio, 
                        Qt.SmoothTransformation
                    ))

File: .\electroninja\ui\panels\right_panel.py
---------------------------------------------
#right_panel.py


import logging
from PyQt5.QtWidgets import (
    QFrame, QVBoxLayout, QLabel, QSizePolicy
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QFont
from electroninja.ui.components.chat_panel import ChatPanel
from electroninja.ui.components.chat_input import ChatInputWidget

logger = logging.getLogger('electroninja')

class RightPanel(QFrame):
    """Right panel for chat interface"""
    
    messageSent = pyqtSignal(str)  # Emitted when the user sends a new message
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initUI()
        
    def initUI(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)
        
        # Panel title
        self.chat_title = QLabel("Chat with ElectroNinja", self)
        self.chat_title.setStyleSheet(
            "font-size: 18px; font-weight: bold; color: white; letter-spacing: 0.5px;"
        )
        self.chat_title.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.chat_title)
        
        # Chat messages area (scrollable)
        self.chat_panel = ChatPanel(self)
        self.chat_panel.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        main_layout.addWidget(self.chat_panel, stretch=1)
        
        # Chat input area
        self.chat_input = ChatInputWidget(max_lines=5, parent=self)
        self.chat_input.sendMessage.connect(self.onSendMessage)
        main_layout.addWidget(self.chat_input)
        
    def onSendMessage(self, text):
        """Handle a new message from the user"""
        if not text.strip():
            return
            
        # Add message to chat panel
        self.chat_panel.add_message(text, is_user=True)
        
        # Clear input
        self.chat_input.message_input.clear()
        
        # Emit signal to notify parent
        self.messageSent.emit(text)
        
    def receive_message(self, message):
        """Display a message from the assistant"""
        logger.info(f"Receiving message in chat panel: {message[:50]}...")
        
        # Use a small delay to ensure smooth UI updates
        QTimer.singleShot(50, lambda: self.chat_panel.add_message(message, is_user=False))
        
    def clear_chat(self):
        """Clear all chat messages"""
        self.chat_panel.clear_chat()

File: .\electroninja\ui\panels\__init__.py
------------------------------------------
from electroninja.ui.panels.left_panel import LeftPanel
from electroninja.ui.panels.middle_panel import MiddlePanel
from electroninja.ui.panels.right_panel import RightPanel

__all__ = ['LeftPanel', 'MiddlePanel', 'RightPanel']

File: .\electroninja\utils\async_workers.py
-------------------------------------------
#async_workers.py

from PyQt5.QtCore import QThread, pyqtSignal
import logging

logger = logging.getLogger('electroninja')

class LLMWorker(QThread):
    """Worker thread for asynchronous LLM calls"""

    resultReady = pyqtSignal(str)

    def init(self, func, prompt):
        super().init()
        self.func = func
        self.prompt = prompt

    def run(self):
        logger.info("LLMWorker: Sending prompt to LLM...")
        try:
            result = self.func(self.prompt)
            logger.info("LLMWorker: Received response from LLM.")
            self.resultReady.emit(result)
        except Exception as e:
            logger.error(f"LLMWorker error: {str(e)}")
            self.resultReady.emit(f"Error: {str(e)}")

class CircuitProcessingWorker(QThread):
    """Worker thread for asynchronous circuit processing"""

    statusUpdate = pyqtSignal(str)
    resultReady = pyqtSignal(dict)

    def init(self, feedback_manager, request, examples=None):
        super().init()
        self.feedback_manager = feedback_manager
        self.request = request
        self.examples = examples

    def run(self):
        logger.info(f"CircuitProcessingWorker: Processing request: {self.request}")
        try:
            result = self.feedback_manager.process_request(
                self.request,
                examples=self.examples,
                status_callback=lambda msg: self.statusUpdate.emit(msg)
            )
            self.resultReady.emit(result)
        except Exception as e:
            logger.error(f"CircuitProcessingWorker error: {str(e)}")
            self.resultReady.emit({
                "success": False,
                "error": str(e)
            })

File: .\electroninja\utils\error_handler.py
-------------------------------------------
# error_handler.py

import logging
import traceback
from PyQt5.QtWidgets import QMessageBox

# Custom exceptions
class ElectroNinjaError(Exception):
    """Base exception for all ElectroNinja errors"""
    pass

class LTSpiceError(ElectroNinjaError):
    """Exception raised for errors in LTSpice processing"""
    pass

class ModelError(ElectroNinjaError):
    """Exception raised for errors in LLM model interactions"""
    pass

class FileError(ElectroNinjaError):
    """Exception raised for errors in file operations"""
    pass

def log_error(error, context=None):
    """Log an error with stack trace and context info"""
    logger = logging.getLogger('electroninja')
    error_message = f"{type(error).__name__}: {str(error)}"
    
    if context:
        error_message = f"{error_message} - Context: {context}"
    
    logger.error(error_message)
    logger.error(traceback.format_exc())
    
    return error_message

def show_error_dialog(parent, title, message, details=None):
    """Show an error dialog to the user"""
    msg_box = QMessageBox(parent)
    msg_box.setIcon(QMessageBox.Critical)
    msg_box.setWindowTitle(title)
    msg_box.setText(message)
    
    if details:
        msg_box.setDetailedText(details)
    
    msg_box.setStandardButtons(QMessageBox.Ok)
    msg_box.exec_()

def handle_error(error, parent=None, context=None, show_dialog=True):
    """Comprehensive error handling function"""
    # Log the error
    error_message = log_error(error, context)
    
    # Show dialog if requested and parent widget is provided
    if show_dialog and parent:
        show_error_dialog(
            parent, 
            "Error", 
            f"An error occurred: {str(error)}", 
            traceback.format_exc()
        )
    
    return error_message

File: .\electroninja\utils\file_operations.py
---------------------------------------------
#file_operations.py

import os
import shutil
import tempfile
import logging
from electroninja.utils.error_handler import FileError

logger = logging.getLogger('electroninja')

def create_temp_file(content, suffix=".asc", prefix="electroninja_", dir=None):
    """
    Create a temporary file with the given content
    
    Args:
        content (str): Content to write to the file
        suffix (str): File suffix
        prefix (str): File prefix
        dir (str): Directory to create the file in
        
    Returns:
        str: Path to the created temporary file
    """
    try:
        # Create a temporary file
        temp_file = tempfile.NamedTemporaryFile(
            delete=False, 
            suffix=suffix, 
            prefix=prefix, 
            mode="w", 
            dir=dir
        )
        
        # Write content to the file
        temp_file.write(content)
        temp_file_path = temp_file.name
        temp_file.close()
        
        logger.info(f"Created temporary file: {temp_file_path}")
        return temp_file_path
        
    except Exception as e:
        raise FileError(f"Failed to create temporary file: {str(e)}")

def save_file(content, file_path, encoding="utf-8"):
    """
    Save content to a file
    
    Args:
        content (str): Content to write to the file
        file_path (str): Path to the file
        encoding (str): File encoding
        
    Returns:
        str: Path to the saved file
    """
    try:
        # Create directory if it doesn't exist
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        
        # Write content to the file
        with open(file_path, "w", encoding=encoding) as f:
            f.write(content)
            
        logger.info(f"Saved file: {file_path}")
        return file_path
        
    except Exception as e:
        raise FileError(f"Failed to save file: {str(e)}")

def read_file(file_path, encoding="utf-8", errors="replace"):
    """
    Read content from a file
    
    Args:
        file_path (str): Path to the file
        encoding (str): File encoding
        errors (str): How to handle encoding errors
        
    Returns:
        str: Content of the file
    """
    try:
        if not os.path.exists(file_path):
            raise FileError(f"File not found: {file_path}")
            
        with open(file_path, "r", encoding=encoding, errors=errors) as f:
            content = f.read()
            
        return content
        
    except Exception as e:
        if isinstance(e, FileError):
            raise e
        raise FileError(f"Failed to read file: {str(e)}")

def copy_file(src, dst):
    """
    Copy a file from source to destination
    
    Args:
        src (str): Source file path
        dst (str): Destination file path
        
    Returns:
        str: Path to the destination file
    """
    try:
        # Create directory if it doesn't exist
        os.makedirs(os.path.dirname(dst), exist_ok=True)
        
        # Copy the file
        shutil.copy2(src, dst)
        
        logger.info(f"Copied file from {src} to {dst}")
        return dst
        
    except Exception as e:
        raise FileError(f"Failed to copy file: {str(e)}")

def create_output_directory(base_dir):
    """
    Create a new output directory with incremental naming
    
    Args:
        base_dir (str): Base directory
        
    Returns:
        str: Path to the created directory
    """
    try:
        # Create base directory if it doesn't exist
        os.makedirs(base_dir, exist_ok=True)
        
        # Find the next available directory name
        iteration = 0
        while os.path.exists(os.path.join(base_dir, f"output-{iteration}")):
            iteration += 1
            
        # Create the new directory
        output_dir = os.path.join(base_dir, f"output-{iteration}")
        os.makedirs(output_dir)
        
        logger.info(f"Created output directory: {output_dir}")
        return output_dir
        
    except Exception as e:
        raise FileError(f"Failed to create output directory: {str(e)}")

File: .\electroninja\utils\__init__.py
--------------------------------------
# This file intentionally left empty

File: .\tests\test_asc_generation_rag.py
----------------------------------------
# tests/test_asc_generation_with_rag.py
import os
import sys
import logging
import openai
from dotenv import load_dotenv

# Add parent directory to path to allow imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from electroninja.config.settings import Config
from electroninja.llm.providers.openai import OpenAIProvider
from electroninja.llm.vector_store import VectorStore
from electroninja.llm.prompts.circuit_prompts import (
    GENERAL_INSTRUCTION,
    SAFETY_FOR_AGENT,
    RAG_ASC_GENERATION_PROMPT
)

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def extract_clean_asc_code(asc_code):
    """
    Extract only the pure ASC code starting from 'Version 4'
    This ensures we don't include descriptions in the ASC code examples
    """
    if "Version 4" in asc_code:
        idx = asc_code.find("Version 4")
        return asc_code[idx:].strip()
    return asc_code.strip()

def test_asc_generation_with_rag(prompt):
    """
    Test ASC code generation using RAG (Retrieval Augmented Generation)
    
    Args:
        prompt (str): User prompt for circuit design
        
    Returns:
        dict: Dictionary with generation results
    """
    # Initialize components
    config = Config()
    llm_provider = OpenAIProvider(config)
    vector_store = VectorStore(config)
    
    # Initialize result dictionary
    result = {
        "prompt": prompt,
        "asc_code": "",
        "num_examples": 0,
        "examples": []
    }
    
    print("\n====== TEST: ASC GENERATION WITH RAG ======\n")
    
    # Load vector store
    print("Loading vector store...")
    vector_store.load()
    print("Vector store loaded successfully")
    
    # Fetch examples from vector database
    print("Fetching similar examples from vector DB...")
    examples = vector_store.search(prompt)
    
    result["num_examples"] = len(examples)
    print(f"Found {len(examples)} similar examples")
    
    # Process examples for the prompt
    examples_text = ""
    for i, example in enumerate(examples, start=1):
        # Get description from metadata
        desc = example.get("metadata", {}).get("description", "No description")
        
        # Get ASC code, preferring pure_asc_code if available
        if "metadata" in example and "pure_asc_code" in example["metadata"]:
            asc_code = example["metadata"]["pure_asc_code"]
        else:
            # Fall back to asc_code field
            asc_code = example.get("asc_code", "")
        
        # Ensure we only have the clean ASC code without descriptions
        asc_code = extract_clean_asc_code(asc_code)
        
        # Store for result
        result["examples"].append({
            "description": desc,
            "asc_code": asc_code
        })
        
        # Format with clear separation for the prompt
        examples_text += (
            f"Example {i}:\n"
            f"Description: {desc}\n"
            f"ASC Code:\n"
            f"-----------------\n"
            f"{asc_code}\n"
            f"-----------------\n\n"
        )
    
    # Construct o3-mini prompt
    system_prompt = f"{GENERAL_INSTRUCTION}\n\n{SAFETY_FOR_AGENT}"
    
    user_prompt = (
        "Below are examples of circuits similar to the user's request:\n\n"
        f"{examples_text}"
        f"User's request: {prompt}\n\n"
        f"{RAG_ASC_GENERATION_PROMPT}"
    )
    
    print("=== SYSTEM PROMPT SENT TO o3-mini ===")
    print(system_prompt)
    print("\n===========================\n")
    
    print("=== USER PROMPT SENT TO o3-mini ===")
    print(user_prompt)
    print("\n===========================\n")
    
    # Generate ASC code from o3-mini
    try:
        response = openai.ChatCompletion.create(
            model=llm_provider.asc_gen_model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
        )
        
        # Extract and process response
        asc_response = response.choices[0].message.content.strip()
        
        # Clean the ASC code if needed
        if asc_response.upper() != "N":
            asc_response = extract_clean_asc_code(asc_response)
        
        result["asc_code"] = asc_response
        
        print("=== RESPONSE FROM o3-mini ===")
        print(asc_response)
        print("\n===========================\n")
        
        # Check if the ASC code looks valid
        if "Version 4" in asc_response:
            print("✅ Valid ASC code detected")
        elif asc_response.upper() == "N":
            print("⚠️ Model responded with 'N' - indicating not a circuit request")
        else:
            print("⚠️ Response may not be valid ASC code")
        
    except Exception as e:
        print(f"Error generating ASC code: {str(e)}")
        result["error"] = str(e)
    
    return result

if __name__ == "__main__":
    # Sample circuit prompts to test
    prompts = [
        "Create a circuit with two resistors in parallel",
        "Design a simple RC low-pass filter"
    ]
    
    # Test each prompt
    for prompt in prompts:
        print(f"\n\n*** TESTING PROMPT: '{prompt}' ***\n")
        result = test_asc_generation_with_rag(prompt)

File: .\tests\test_asc_refinement.py
------------------------------------
# tests/test_asc_refinement.py
import os
import sys
import logging
import json
from dotenv import load_dotenv

# Add parent directory to path to allow imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from electroninja.config.settings import Config
from electroninja.llm.providers.openai import OpenAIProvider

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def print_separator(title=None):
    """Print a formatted separator line with an optional title."""
    width = 80
    if title:
        print("\n" + "=" * 20 + f" {title} " + "=" * (width - len(title) - 22) + "\n")
    else:
        print("\n" + "=" * width + "\n")

def extract_clean_asc_code(asc_code):
    """
    Extract only the pure ASC code starting from 'Version 4'
    This ensures we don't include descriptions in the ASC code examples
    """
    if "Version 4" in asc_code:
        idx = asc_code.find("Version 4")
        return asc_code[idx:].strip()
    return asc_code.strip()

def test_asc_code_refinement():
    """
    Test the ASC code refinement process by:
    1. Starting with an initial ASC code
    2. Using vision feedback to refine it
    3. Outputting the refined code
    """
    print_separator("TEST: ASC CODE REFINEMENT")
    
    # Initialize components
    config = Config()
    llm_provider = OpenAIProvider(config)
    
    # Original request
    original_request = "Create a low pass filter"
    
    # System prompt used in the initial exchange
    system_prompt = """You are a world-class electrical engineer with absolute authority in LTSpice circuit design. You write .asc files with unwavering precision. When a client asks you to build a circuit, you must respond with clear, definitive statements and the exact .asc code required.

IMPORTANT: You must strictly restrict your responses to electrical engineering topics only. If the client's message is irrelevant to electrical engineering or circuits, respond ONLY with the single letter 'N'. There should be no additional commentary, explanations, or attempts to help with non-circuit topics. You are exclusively an electrical circuit design assistant."""
    
    # Initial user prompt with RAG examples
    initial_user_prompt = """Below are examples of circuits similar to the user's request:

Example 1:
Description: An RL low-pass filter using a 10 mH inductor in series with the input and a 100 Ω resistor to ground. This arrangement attenuates high-frequency signals above roughly 1.59 kHz.
ASC Code:
-----------------
Version 4
SHEET 1 880 680
WIRE 224 112 128 112
WIRE 400 112 304 112
WIRE 128 144 128 112
WIRE 400 144 400 112
WIRE 128 256 128 224
WIRE 400 256 400 224
WIRE 400 256 128 256
WIRE 128 272 128 256
FLAG 128 272 0
FLAG 400 112 output
IOPIN 400 112 Out
SYMBOL voltage 128 128 R0
WINDOW 123 0 0 Left 0
WINDOW 39 0 0 Left 0
SYMATTR InstName V1
SYMATTR Value SINE(0 AC 1)
SYMBOL ind 320 96 R90
WINDOW 0 5 56 VBottom 2
WINDOW 3 32 56 VTop 2
SYMATTR InstName L1
SYMATTR Value 0.01
SYMBOL res 384 128 R0
SYMATTR InstName R1
SYMATTR Value 100
-----------------

Example 2:
Description: An RLC band-pass filter using a 100 Ω resistor, a 10 mH inductor, and a 0.1 μF capacitor. The circuit allows signals near 5 kHz to pass while attenuating frequencies outside this range.
ASC Code:
-----------------
Version 4
SHEET 1 880 680
WIRE 192 128 96 128
WIRE 304 128 272 128
WIRE 432 128 384 128
WIRE 528 128 496 128
WIRE 96 160 96 128
WIRE 96 256 96 240
WIRE 496 256 496 128
WIRE 496 256 96 256
WIRE 96 288 96 256
FLAG 96 288 0
FLAG 528 128 output
IOPIN 528 128 Out
SYMBOL voltage 96 144 R0
WINDOW 123 0 0 Left 0
WINDOW 39 0 0 Left 0
SYMATTR InstName V1
SYMATTR Value SINE(0 AC 1)
SYMBOL res 288 112 R90
WINDOW 0 0 56 VBottom 2
WINDOW 3 32 56 VTop 2
SYMATTR InstName R1
SYMATTR Value 100
SYMBOL cap 496 112 R90
WINDOW 0 0 32 VBottom 2
WINDOW 3 32 32 VTop 2
SYMATTR InstName C1
SYMATTR Value 0.1e-6
SYMBOL ind 400 112 R90
WINDOW 0 5 56 VBottom 2
WINDOW 3 32 56 VTop 2
SYMATTR InstName L1
SYMATTR Value 0.01
-----------------

Example 3:
Description: An RL high-pass filter circuit using a 100 Ω resistor in series with the input and a 10 mH inductor to ground. It passes high-frequency signals while attenuating those below approximately 1.59 kHz (cutoff frequency f_c = R/(2πL)).
ASC Code:
-----------------
Version 4
SHEET 1 880 680
WIRE 176 128 96 128
WIRE 320 128 256 128
WIRE 96 160 96 128
WIRE 320 160 320 128
WIRE 96 256 96 240
WIRE 320 256 320 240
WIRE 320 256 96 256
WIRE 96 272 96 256
FLAG 96 272 0
FLAG 320 128 output
IOPIN 320 128 Out
SYMBOL ind 304 144 R0
SYMATTR InstName L1
SYMATTR Value 0.01
SYMBOL res 160 144 R270
WINDOW 0 32 56 VTop 2
WINDOW 3 0 56 VBottom 2
SYMATTR InstName R1
SYMATTR Value 100
SYMBOL voltage 96 144 R0
SYMATTR InstName V1
-----------------

User's request: Create a low pass filter

Now, based on the examples above, generate the complete .asc code for a circuit that meets the user's request.

CRITICAL INSTRUCTIONS:
1. Your output MUST begin with 'Version 4' and contain ONLY valid LTSpice ASC code
2. Do NOT include ANY descriptions, explanations, or comments before the ASC code
3. Do NOT include ANY text that is not part of the ASC file format
4. If the request is not related to circuits, respond only with 'N'

OUTPUT FORMAT (exact):
Version 4
SHEET 1 ...
... [remaining ASC code] ..."""
    
    # Initial ASC code (iteration 0) - o3-mini's response
    initial_asc_code = """Version 4
SHEET 1 880 680
WIRE 224 112 128 112
WIRE 400 112 304 112
WIRE 128 144 128 112
WIRE 400 144 400 112
WIRE 128 256 128 224
WIRE 400 256 400 224
WIRE 400 256 128 256
WIRE 128 272 128 256
FLAG 128 272 0
FLAG 400 112 output
IOPIN 400 112 Out
SYMBOL voltage 128 128 R0
WINDOW 123 0 0 Left 0
WINDOW 39 0 0 Left 0
SYMATTR InstName V1
SYMATTR Value SINE(0 AC 1)
SYMBOL ind 320 96 R90
WINDOW 0 5 56 VBottom 2
WINDOW 3 32 56 VTop 2
SYMATTR InstName L1
SYMATTR Value 0.01
SYMBOL res 384 128 R0
SYMATTR InstName R1
SYMATTR Value 100"""
    
    # Vision feedback for iteration 0
    vision_feedback = """1. **What's wrong with the current implementation:**

   The circuit consists of an inductor (L1) and a resistor (R1) in series with an AC source. While inductors can be used to create filters, this particular arrangement does not constitute a low-pass filter configuration on its own.

2. **Why it doesn't meet the requirements:**

   - A low-pass filter typically allows low-frequency signals to pass while attenuating high-frequency signals. In the classic low-pass filter, the simplest form would be an RC (resistor-capacitor) low-pass filter, which uses a resistor (R) and a capacitor (C) in series, with the output taken across the capacitor.
   - Here, we have an RL series circuit, which behaves differently. It does not serve the purpose of a low-pass filter in the standard sense. Instead, an RL series circuit with output across the inductor is more commonly used for high-pass filtering due to the inductor's tendency to block high-frequency signals.

3. **Detailed recommendations for fixing the circuit:**

   - Replace the inductor (L1) with a capacitor (C1). Connect the capacitor in parallel with the resistor (R1) to form a classic RC low-pass filter.
   - If an RL filter is specifically required, ensure the correct configuration and note that it will typically result in a high-pass filter.

4. **Expected behavior after the modifications:**

   - After replacing the inductor with a capacitor and forming a proper RC low-pass filter, the circuit will allow signals with frequencies lower than a certain cutoff frequency to pass with little attenuation.
   - The cutoff frequency (\\( f_c \\)) of an RC low-pass filter is determined by the formula:

     \\[
     f_c = \\frac{1}{2\\pi RC}
     \\]

   - Adjust the resistor and capacitor values to achieve the desired cutoff frequency."""
    
    # Create conversation history with complete context
    history = [
        {
            "iteration": 0,
            "system_prompt": system_prompt,
            "user_prompt": initial_user_prompt,
            "asc_code": initial_asc_code,
            "vision_feedback": vision_feedback
        }
    ]
    
    print(f"Original request: {original_request}")
    
    # Display initial system prompt
    print("\nInitial system prompt:")
    print("-" * 60)
    print(system_prompt)
    print("-" * 60)
    
    # Display initial user prompt with RAG
    print("\nInitial user prompt with RAG examples:")
    print("-" * 60)
    print(initial_user_prompt)
    print("-" * 60)
    
    # Display initial ASC code
    print("\nInitial ASC code (iteration 0) - o3-mini's response:")
    print("-" * 60)
    print(initial_asc_code)
    print("-" * 60)
    
    # Display vision feedback
    print("\nVision feedback for iteration 0:")
    print("-" * 60)
    print(vision_feedback)
    print("-" * 60)
    
    # Refine ASC code
    print_separator("REFINING ASC CODE")
    
    try:
        # Build raw refinement prompt (for debugging)
        prompt = "Below are previous attempts and feedback:\n\n"
        
        for item in history:
            prompt += f"Attempt {item.get('iteration', '?')} ASC code:\n{item['asc_code']}\n\n"
            prompt += f"Vision feedback (Iteration {item.get('iteration','?')}): {item['vision_feedback']}\n\n"
            
        prompt += f"Original user's request: {original_request}\n\n"
        
        from electroninja.llm.prompts.circuit_prompts import REFINEMENT_PROMPT_TEMPLATE
        prompt += REFINEMENT_PROMPT_TEMPLATE
        
        print("\nRAW REFINEMENT PROMPT:")
        print("-" * 60)
        print(prompt)
        print("-" * 60)
        
        # Get refined ASC code
        refined_asc = llm_provider.refine_asc_code(original_request, history)
        
        # Clean the ASC code if needed
        refined_asc = extract_clean_asc_code(refined_asc)
        
        print("\nREFINED ASC CODE:")
        print("-" * 60)
        print(refined_asc)
        print("-" * 60)
        
        # Add to history for potential further iterations
        history.append({
            "iteration": 1,
            "asc_code": refined_asc,
            "vision_feedback": "Not analyzed yet" # Would be filled by vision model in real scenario
        })
        
        # Save history to JSON for reference
        with open("refinement_history.json", "w") as f:
            json.dump(history, f, indent=2)
        print("\nSaved refinement history to refinement_history.json")
        
        print_separator("TEST COMPLETED")
        return True
        
    except Exception as e:
        print(f"Error during refinement test: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    test_asc_code_refinement()

File: .\tests\test_circuit_chat_response.py
-------------------------------------------
# tests/test_circuit_chat_response.py
import os
import sys
import logging
import openai
from dotenv import load_dotenv

# Add parent directory to path to allow imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from electroninja.config.settings import Config
from electroninja.llm.providers.openai import OpenAIProvider
from electroninja.llm.prompts.circuit_prompts import GENERAL_INSTRUCTION
from electroninja.llm.prompts.chat_prompts import (
    CIRCUIT_CHAT_PROMPT,
    NON_CIRCUIT_CHAT_PROMPT
)

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def test_circuit_chat_response(prompt, is_circuit_related):
    """
    Test generating chat responses for user requests based on whether the request 
    is circuit-related or not (without performing evaluation).
    
    Args:
        prompt (str): User prompt
        is_circuit_related (bool): Whether the prompt is related to circuits
    
    Returns:
        dict: Dictionary with chat response results
    """
    # Initialize components
    config = Config()
    llm_provider = OpenAIProvider(config)
    
    # Initialize result dictionary
    result = {
        "prompt": prompt,
        "is_circuit_related": is_circuit_related,
        "chat_response": ""
    }
    
    print("\n====== TEST: CIRCUIT CHAT RESPONSE ======\n")
    print(f"Processing prompt: '{prompt}'")
    print(f"Circuit-related: {'Yes' if is_circuit_related else 'No'}")
    
    # Generate appropriate chat prompt based on circuit relevance
    if is_circuit_related:
        chat_prompt = f"{GENERAL_INSTRUCTION}\n{CIRCUIT_CHAT_PROMPT.format(prompt=prompt)}"
        print("\nUsing CIRCUIT_CHAT_PROMPT for circuit-related request")
    else:
        chat_prompt = f"{GENERAL_INSTRUCTION}\n{NON_CIRCUIT_CHAT_PROMPT.format(prompt=prompt)}"
        print("\nUsing NON_CIRCUIT_CHAT_PROMPT for non-circuit-related request")
    
    print("\n=== PROMPT SENT TO gpt-4o-mini ===")
    print(chat_prompt)
    print("\n===========================\n")
    
    # Generate chat response
    try:
        response = openai.ChatCompletion.create(
            model=llm_provider.chat_model,
            messages=[{"role": "user", "content": chat_prompt}]
        )
        
        # Extract and store response
        chat_response = response.choices[0].message.content.strip()
        result["chat_response"] = chat_response
        
        print("=== RESPONSE FROM gpt-4o-mini ===")
        print(chat_response)
        print("\n===========================\n")

        
    except Exception as e:
        print(f"Error generating chat response: {str(e)}")
        result["error"] = str(e)
    
    return result

if __name__ == "__main__":
    # Sample prompts to test
    circuit_prompts = [
        "Create a circuit with two resistors in parallel"
    ]
    
    non_circuit_prompts = [
        "Tell me about World War 2"
    ]
    
    # Test circuit-related prompts
    print("\n\n=== TESTING CIRCUIT-RELATED PROMPTS ===\n")
    for prompt in circuit_prompts:
        print(f"\n*** TESTING PROMPT: '{prompt}' ***\n")
        result = test_circuit_chat_response(prompt, is_circuit_related=True)
    
    # Test non-circuit-related prompts
    print("\n\n=== TESTING NON-CIRCUIT-RELATED PROMPTS ===\n")
    for prompt in non_circuit_prompts:
        print(f"\n*** TESTING PROMPT: '{prompt}' ***\n")
        result = test_circuit_chat_response(prompt, is_circuit_related=False)

File: .\tests\test_circuit_evaluation.py
----------------------------------------
# tests/test_circuit_evaluation.py
import os
import sys
import logging
import openai
from dotenv import load_dotenv

# Add parent directory to path to allow imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from electroninja.config.settings import Config
from electroninja.llm.providers.openai import OpenAIProvider
from electroninja.llm.prompts.circuit_prompts import (
    GENERAL_INSTRUCTION,
    CIRCUIT_RELEVANCE_EVALUATION_PROMPT
)

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def test_circuit_evaluation(prompt):
    """
    Test whether the evaluation model correctly identifies if a request is circuit-related
    
    Args:
        prompt (str): User prompt to evaluate
        
    Returns:
        dict: Dictionary with evaluation results
    """
    # Initialize components
    config = Config()
    llm_provider = OpenAIProvider(config)
    
    # Initialize result dictionary
    result = {
        "prompt": prompt,
        "is_circuit_related": False,
        "raw_evaluation": ""
    }
    
    print("\n====== TEST: CIRCUIT RELEVANCE EVALUATION ======\n")
    
    # Build evaluation prompt
    evaluation_prompt = (
        f"{GENERAL_INSTRUCTION}\n\n"
        f"{CIRCUIT_RELEVANCE_EVALUATION_PROMPT.format(prompt=prompt)}"
    )
    
    print("=== PROMPT SENT TO EVALUATION MODEL (gpt-4o-mini) ===")
    print(evaluation_prompt)
    print("\n===========================\n")
    
    # Call the model
    try:
        response = openai.ChatCompletion.create(
            model=llm_provider.evaluation_model,
            messages=[{"role": "user", "content": evaluation_prompt}]
        )
        
        # Extract and process response
        raw_result = response.choices[0].message.content.strip()
        is_circuit_related = raw_result.upper().startswith('Y')
        
        # Store results
        result["raw_evaluation"] = raw_result
        result["is_circuit_related"] = is_circuit_related
        
        print("=== RAW RESPONSE FROM EVALUATION MODEL ===")
        print(raw_result)
        print("\n===========================\n")
        
        print(f"Final evaluation result: {is_circuit_related} (Circuit-related: {'Yes' if is_circuit_related else 'No'})")
        
    except Exception as e:
        print(f"Error during evaluation: {str(e)}")
        result["error"] = str(e)
    
    return result

if __name__ == "__main__":
    # Sample prompts to test
    prompts = [
        "Create a circuit with two resistors in parallel",
        "Design a simple RC low-pass filter",
        "Tell me about World War 2",
    ]
    
    # Test each prompt
    results = {}
    for prompt in prompts:
        print(f"\n\n*** TESTING PROMPT: '{prompt}' ***\n")
        result = test_circuit_evaluation(prompt)
        results[prompt] = result
    
    # Print summary
    print("\n\n====== TEST SUMMARY ======\n")
    for prompt, result in results.items():
        circuit_result = "Circuit-related" if result["is_circuit_related"] else "Not circuit-related"
        print(f"Prompt: '{prompt}' => {circuit_result}")

File: .\tests\test_full_pipeline.py
-----------------------------------
# tests/test_iterative_pipeline.py
import os
import sys
import time
import logging
import argparse
import threading
import json
from dotenv import load_dotenv

# Add parent directory to path to allow imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from electroninja.config.settings import Config
from electroninja.llm.providers.openai import OpenAIProvider
from electroninja.llm.vector_store import VectorStore
from electroninja.core.ltspice.interface import LTSpiceInterface
from electroninja.llm.vision_analyser import VisionAnalyzer
from electroninja.llm.prompts.circuit_prompts import (
    GENERAL_INSTRUCTION,
    SAFETY_FOR_AGENT,
    CIRCUIT_RELEVANCE_EVALUATION_PROMPT,
    RAG_ASC_GENERATION_PROMPT,
    REFINEMENT_PROMPT_TEMPLATE
)
from electroninja.llm.prompts.chat_prompts import (
    CIRCUIT_CHAT_PROMPT,
    NON_CIRCUIT_CHAT_PROMPT,
    VISION_FEEDBACK_PROMPT
)

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('electroninja')

def print_separator(title=None):
    """Print a formatted separator line with an optional title."""
    width = 80
    if title:
        print("\n" + "=" * 20 + f" {title} " + "=" * (width - len(title) - 22) + "\n")
    else:
        print("\n" + "=" * width + "\n")

def extract_clean_asc_code(asc_code):
    """
    Extract only the pure ASC code starting from 'Version 4'
    This ensures we don't include descriptions in the ASC code examples
    """
    if "Version 4" in asc_code:
        idx = asc_code.find("Version 4")
        return asc_code[idx:].strip()
    return asc_code.strip()

def validate_asc_code(asc_code):
    """
    Validate ASC code to ensure it's properly formed
    
    Args:
        asc_code (str): ASC code to validate
        
    Returns:
        bool: True if valid, False otherwise
    """
    # Check for basic structure
    if not asc_code.startswith("Version 4"):
        print("Invalid ASC code: Does not start with 'Version 4'")
        return False
        
    # Check for duplicate FLAG entries
    flag_lines = [line for line in asc_code.splitlines() if line.startswith("FLAG")]
    flag_targets = [line.split()[1:3] for line in flag_lines if len(line.split()) >= 3]
    if len(flag_targets) != len(set(tuple(target) for target in flag_targets)):
        print("Invalid ASC code: Contains duplicate FLAGS")
        return False
        
    # Check for duplicate SYMBOL entries at same coordinates
    symbol_lines = [line for line in asc_code.splitlines() if line.startswith("SYMBOL")]
    symbol_positions = []
    for line in symbol_lines:
        parts = line.split()
        if len(parts) >= 4:
            try:
                pos = (parts[-2], parts[-1])
                symbol_type = parts[1]
                key = (symbol_type, pos)
                if key in symbol_positions:
                    print(f"Invalid ASC code: Duplicate SYMBOL {symbol_type} at position {pos}")
                    return False
                symbol_positions.append(key)
            except:
                pass
                
    # Ensure there's at least one voltage source
    if not any(line.startswith("SYMBOL voltage") for line in symbol_lines):
        print("Invalid ASC code: No voltage source found")
        return False
        
    return True

def step1_evaluate_circuit_request(prompt, llm_provider):
    """
    Step 1: Evaluate if the prompt is circuit-related
    
    Args:
        prompt (str): User prompt to evaluate
        llm_provider: The LLM provider instance
        
    Returns:
        bool: True if circuit-related, False otherwise
    """
    print_separator("STEP 1: CIRCUIT RELEVANCE EVALUATION")
    print(f"Evaluating if the prompt is circuit-related: '{prompt}'")
    
    evaluation_prompt = f"{GENERAL_INSTRUCTION}\n\n{CIRCUIT_RELEVANCE_EVALUATION_PROMPT.format(prompt=prompt)}"
    
    print("\nRAW PROMPT SENT TO EVALUATION MODEL:")
    print("-" * 40)
    print(evaluation_prompt)
    print("-" * 40)
    
    # Get raw response instead of just boolean to print it
    try:
        import openai
        response = openai.ChatCompletion.create(
            model=llm_provider.evaluation_model,
            messages=[{"role": "user", "content": evaluation_prompt}]
        )
        raw_result = response.choices[0].message.content.strip()
        is_circuit_related = raw_result.upper().startswith('Y')
        
        print("\nRAW EVALUATION RESPONSE:")
        print("-" * 40)
        print(raw_result)
        print("-" * 40)
        
        print(f"Final evaluation result: {is_circuit_related} (Circuit-related: {'Yes' if is_circuit_related else 'No'})")
        
        return is_circuit_related
    except Exception as e:
        print(f"Error during evaluation: {str(e)}")
        return False

def step2a_generate_chat_response(prompt, is_circuit_related, llm_provider):
    """
    Step 2a: Generate chat response based on whether the prompt is circuit-related
    
    Args:
        prompt (str): User prompt
        is_circuit_related (bool): Whether the prompt is related to circuits
        llm_provider: The LLM provider instance
        
    Returns:
        str: Generated chat response
    """
    print_separator("STEP 2A: CHAT RESPONSE GENERATION")
    
    if is_circuit_related:
        chat_prompt = f"{GENERAL_INSTRUCTION}\n{CIRCUIT_CHAT_PROMPT.format(prompt=prompt)}"
        print("\nUsing CIRCUIT_CHAT_PROMPT for circuit-related request")
    else:
        # For non-circuit queries, use a more direct prompt that requests a short, clear response
        chat_prompt = (
            f"{GENERAL_INSTRUCTION}\n"
            f"The user has made a request that is not related to electrical circuits: '{prompt}'.\n\n"
            f"Provide a brief, polite response explaining that this system is specifically designed "
            f"for electrical circuit design and cannot help with this particular request. "
            f"Keep your response under 3 sentences."
        )
        print("\nUsing simplified prompt for non-circuit-related request")
    
    print("\nRAW PROMPT SENT TO CHAT MODEL:")
    print("-" * 40)
    print(chat_prompt)
    print("-" * 40)
    
    try:
        import openai
        response = openai.ChatCompletion.create(
            model=llm_provider.chat_model,
            messages=[{"role": "user", "content": chat_prompt}]
        )
        
        chat_response = response.choices[0].message.content.strip()
        
        print("\nRAW CHAT RESPONSE:")
        print("-" * 40)
        print(chat_response)
        print("-" * 40)
        
        return chat_response
    except Exception as e:
        print(f"Error generating chat response: {str(e)}")
        return "Error generating response"

def step2b_generate_asc_code(prompt, llm_provider, vector_store):
    """
    Step 2b: Generate ASC code based on the prompt using RAG
    
    Args:
        prompt (str): User prompt
        llm_provider: The LLM provider instance
        vector_store: The vector store instance
        
    Returns:
        str: Generated ASC code
    """
    print_separator("STEP 2B: ASC CODE GENERATION")
    
    # Fetch examples from vector database
    print("Fetching similar examples from vector DB...")
    examples = vector_store.search(prompt)
    
    print(f"Found {len(examples)} similar examples")
    
    # Process examples for the prompt
    examples_text = ""
    for i, example in enumerate(examples, start=1):
        # Get description from metadata
        desc = example.get("metadata", {}).get("description", "No description")
        
        # Get ASC code, preferring pure_asc_code if available
        if "metadata" in example and "pure_asc_code" in example["metadata"]:
            asc_code = example["metadata"]["pure_asc_code"]
        else:
            # Fall back to asc_code field
            asc_code = example.get("asc_code", "")
        
        # Ensure we only have the clean ASC code without descriptions
        asc_code = extract_clean_asc_code(asc_code)
        
        # Format with clear separation for the prompt
        examples_text += (
            f"Example {i}:\n"
            f"Description: {desc}\n"
            f"ASC Code:\n"
            f"-----------------\n"
            f"{asc_code}\n"
            f"-----------------\n\n"
        )
    
    # Construct prompt
    system_prompt = f"{GENERAL_INSTRUCTION}\n\n{SAFETY_FOR_AGENT}"
    
    user_prompt = (
        "Below are examples of circuits similar to the user's request:\n\n"
        f"{examples_text}"
        f"User's request: {prompt}\n\n"
        f"{RAG_ASC_GENERATION_PROMPT}"
    )
    
    print("\nRAW SYSTEM PROMPT SENT TO ASC GENERATION MODEL:")
    print("-" * 40)
    print(system_prompt)
    print("-" * 40)
    
    print("\nRAW USER PROMPT SENT TO ASC GENERATION MODEL:")
    print("-" * 40)
    print(user_prompt)
    print("-" * 40)
    
    try:
        import openai
        response = openai.ChatCompletion.create(
            model=llm_provider.asc_gen_model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
        )
        
        asc_code = response.choices[0].message.content.strip()
        
        # Clean the ASC code if needed
        if asc_code.upper() != "N":
            asc_code = extract_clean_asc_code(asc_code)
        
        print("\nRAW ASC CODE GENERATED:")
        print("-" * 40)
        print(asc_code)
        print("-" * 40)
        
        # Validate the generated ASC code
        if validate_asc_code(asc_code):
            print("ASC code validation passed")
            return asc_code
        else:
            print("ASC code validation failed - will retry generation")
            # Could implement a retry mechanism here
            return asc_code  # Still return for now
            
    except Exception as e:
        print(f"Error generating ASC code: {str(e)}")
        return "Error: Failed to generate circuit"

def step3_process_ltspice(asc_code, ltspice_interface, prompt_id=1, iteration=0):
    """
    Step 3: Process the ASC code with LTSpice
    
    Args:
        asc_code (str): ASC code to process
        ltspice_interface: The LTSpice interface instance
        prompt_id (int): Prompt ID for folder structure
        iteration (int): Iteration number for folder structure
        
    Returns:
        tuple: (asc_path, image_path) on success, or None on failure
    """
    print_separator(f"STEP 3: LTSPICE PROCESSING (ITERATION {iteration})")
    
    print("Processing ASC code with LTSpice...")
    print(f"ASC code length: {len(asc_code)} characters")
    print(f"First 100 chars: {asc_code[:100]}...")
    
    # Validate ASC code before sending to LTSpice
    if not validate_asc_code(asc_code):
        print("Error: Invalid ASC code. Skipping LTSpice processing.")
        return None
    
    result = ltspice_interface.process_circuit(asc_code, prompt_id=prompt_id, iteration=iteration)
    
    if result:
        asc_path, image_path = result
        print(f"\nLTSpice processing successful!")
        print(f"ASC file saved to: {asc_path}")
        print(f"Image saved to: {image_path}")
        return result
    else:
        print("\nLTSpice processing failed!")
        return None

def step4_analyze_vision(image_path, original_request, vision_analyzer):
    """
    Step 4: Analyze the circuit image using vision model
    
    Args:
        image_path (str): Path to the circuit image
        original_request (str): Original user request
        vision_analyzer: The vision analyzer instance
        
    Returns:
        str: Vision analysis result
    """
    print_separator("STEP 4: VISION ANALYSIS")
    
    print(f"Analyzing image at: {image_path}")
    print(f"Original request: {original_request}")
    
    # Since we don't have direct access to the Vision Analyzer's raw prompt,
    # we'll just call the analyze method and print the result
    vision_feedback = vision_analyzer.analyze_circuit_image(image_path, original_request)
    
    print("\nRAW VISION FEEDBACK:")
    print("-" * 40)
    print(vision_feedback)
    print("-" * 40)
    
    return vision_feedback

def step5a_generate_feedback_response(vision_feedback, llm_provider):
    """
    Step 5a: Generate user-friendly response based on vision feedback
    
    Args:
        vision_feedback (str): Feedback from vision model
        llm_provider: The LLM provider instance
        
    Returns:
        str: User-friendly response
    """
    print_separator("STEP 5A: FEEDBACK RESPONSE")
    
    is_success = vision_feedback.strip() == 'Y'
    print(f"Circuit implementation success: {is_success}")
    
    # Build prompt based on feedback
    prompt = VISION_FEEDBACK_PROMPT.format(
        vision_feedback=vision_feedback
    )
    
    print("\nRAW PROMPT SENT TO FEEDBACK MODEL:")
    print("-" * 40)
    print(prompt)
    print("-" * 40)
    
    try:
        import openai
        response = openai.ChatCompletion.create(
            model=llm_provider.chat_model,
            messages=[{"role": "user", "content": prompt}]
        )
        
        feedback_response = response.choices[0].message.content.strip()
        
        print("\nRAW FEEDBACK RESPONSE:")
        print("-" * 40)
        print(feedback_response)
        print("-" * 40)
        
        return feedback_response
    except Exception as e:
        print(f"Error generating feedback response: {str(e)}")
        # Provide a default response in case of error
        if vision_feedback.strip() == 'Y':
            return "Your circuit is complete and meets the requirements."
        else:
            return "I identified some issues with the circuit that need to be addressed."

def step5b_refine_asc_code(prompt, history, llm_provider):
    """
    Step 5b: Refine ASC code based on vision feedback history
    
    Args:
        prompt (str): Original user request
        history (list): List of dictionaries containing previous iterations
        llm_provider: The LLM provider instance
        
    Returns:
        str: Refined ASC code
    """
    print_separator("STEP 5B: ASC CODE REFINEMENT")
    
    # Build refinement prompt - FIXED: use a separate variable for each part of the prompt
    refinement_prompt_parts = ["Below are previous attempts and feedback:\n\n"]
    
    for item in history:
        refinement_prompt_parts.append(f"Attempt {item.get('iteration', '?')} ASC code:\n{item['asc_code']}\n\n")
        refinement_prompt_parts.append(f"Vision feedback (Iteration {item.get('iteration','?')}): {item['vision_feedback']}\n\n")
        
    refinement_prompt_parts.append(f"Original user's request: {prompt}\n\n")
    refinement_prompt_parts.append(REFINEMENT_PROMPT_TEMPLATE)
    
    # Join the parts to create the final prompt
    refinement_prompt = "".join(refinement_prompt_parts)
    
    print("\nRAW REFINEMENT PROMPT SENT TO ASC REFINEMENT MODEL:")
    print("-" * 40)
    print(refinement_prompt)
    print("-" * 40)
    
    try:
        # Call the ASC refinement model
        import openai
        response = openai.ChatCompletion.create(
            model=llm_provider.asc_gen_model,
            messages=[
                {"role": "system", "content": GENERAL_INSTRUCTION},
                {"role": "user", "content": refinement_prompt}
            ]
        )
        
        refined_asc = response.choices[0].message.content.strip()
        
        # Clean the ASC code if needed
        if "Version 4" in refined_asc:
            refined_asc = extract_clean_asc_code(refined_asc)
        
        print("\nREFINED ASC CODE:")
        print("-" * 40)
        print(refined_asc)
        print("-" * 40)
        
        # Validate the refined ASC code
        if validate_asc_code(refined_asc):
            print("Refined ASC code validation passed")
        else:
            print("Refined ASC code validation failed")
        
        return refined_asc
    except Exception as e:
        print(f"Error refining ASC code: {str(e)}")
        return f"Error: Failed to refine circuit: {str(e)}"

def test_iterative_pipeline(prompt, prompt_id=1, max_iterations=3):
    """
    Test the entire pipeline with a given prompt for multiple iterations
    
    Args:
        prompt (str): User prompt to test
        prompt_id (int): ID for folder structure
        max_iterations (int): Maximum number of iterations to perform
    """
    # Initialize components
    config = Config()
    llm_provider = OpenAIProvider(config)
    vector_store = VectorStore(config)
    ltspice_interface = LTSpiceInterface(config)
    vision_analyzer = VisionAnalyzer(config)
    
    # Initialize result dictionary
    result = {
        "prompt": prompt,
        "prompt_id": prompt_id,
        "is_circuit_related": False,
        "chat_response": "",
        "iterations": []
    }
    
    print("\n\n")
    print("=" * 80)
    print(f"TESTING ITERATIVE PIPELINE WITH PROMPT: '{prompt}'")
    print(f"MAXIMUM ITERATIONS: {max_iterations}")
    print("=" * 80)
    print("\n")
    
    # Load vector store
    print("Loading vector store...")
    vector_store.load()
    print("Vector store loaded successfully")
    
    start_time = time.time()
    
    try:
        # Step 1: Evaluate if circuit-related
        is_circuit_related = step1_evaluate_circuit_request(prompt, llm_provider)
        result["is_circuit_related"] = is_circuit_related
        
        if not is_circuit_related:
            print_separator("NON-CIRCUIT REQUEST DETECTED")
            print("Stopping pipeline early - will only generate a brief chat response.")
            chat_response = step2a_generate_chat_response(prompt, is_circuit_related, llm_provider)
            result["chat_response"] = chat_response
            print("\nTest completed for non-circuit request.")
            return result
        
        # Only continue with circuit-related requests
        print_separator("CIRCUIT REQUEST CONFIRMED - CONTINUING PIPELINE")
        
        # Generate chat response
        chat_response = step2a_generate_chat_response(prompt, is_circuit_related, llm_provider)
        result["chat_response"] = chat_response
        
        # Generate initial ASC code
        asc_code = step2b_generate_asc_code(prompt, llm_provider, vector_store)
        
        # Check if valid ASC code was generated
        if asc_code == "N" or not asc_code or asc_code.startswith("Error"):
            print_separator("INVALID ASC CODE")
            print("ASC generation failed or request was misclassified as circuit-related.")
            return result
        
        # Start iterative process
        current_iteration = 0
        history = []
        circuit_verified = False
        current_asc_code = asc_code
        
        # Perform iterations until circuit is verified or max iterations reached
        while current_iteration < max_iterations:
            print_separator(f"STARTING ITERATION {current_iteration}")
            
            # Step 3: Process with LTSpice
            ltspice_result = step3_process_ltspice(current_asc_code, ltspice_interface, 
                                                  prompt_id=prompt_id, 
                                                  iteration=current_iteration)
            
            if not ltspice_result:
                print_separator(f"LTSPICE PROCESSING FAILED (ITERATION {current_iteration})")
                break
            
            asc_path, image_path = ltspice_result
            
            # Step 4: Analyze vision
            vision_feedback = step4_analyze_vision(image_path, prompt, vision_analyzer)
            
            # Store iteration data
            iteration_data = {
                "iteration": current_iteration,
                "asc_code": current_asc_code,
                "asc_path": asc_path,
                "image_path": image_path,
                "vision_feedback": vision_feedback
            }
            
            # Step 5a: Generate feedback response
            feedback_response = step5a_generate_feedback_response(vision_feedback, llm_provider)
            iteration_data["feedback_response"] = feedback_response
            
            # Add to history
            history.append(iteration_data)
            result["iterations"].append(iteration_data)
            
            # Check if circuit is verified
            if vision_feedback.strip() == 'Y':
                print_separator(f"CIRCUIT VERIFIED (ITERATION {current_iteration})")
                circuit_verified = True
                break
                
            # Check if we should continue
            if current_iteration >= max_iterations - 1:
                print_separator(f"REACHED MAXIMUM ITERATIONS ({max_iterations})")
                break
            
            # Step 5b: Refine ASC code for next iteration
            print_separator(f"REFINING ASC CODE FOR ITERATION {current_iteration + 1}")
            refined_asc_code = step5b_refine_asc_code(prompt, history, llm_provider)
            
            # Check if we have a valid refined ASC code
            if not refined_asc_code or refined_asc_code.startswith("Error") or not validate_asc_code(refined_asc_code):
                print_separator(f"REFINEMENT FAILED (ITERATION {current_iteration})")
                break
                
            # Update for next iteration
            iteration_data["refined_asc_code"] = refined_asc_code
            current_asc_code = refined_asc_code
            current_iteration += 1
            
        # Save complete history to JSON file
        history_path = f"pipeline_history_prompt{prompt_id}.json"
        with open(history_path, "w") as f:
            json.dump({
                "prompt": prompt,
                "chat_response": chat_response,
                "iterations": history
            }, f, indent=2)
        print(f"\nSaved complete pipeline history to {history_path}")
        
        # Set final status
        result["final_status"] = "Circuit verified" if circuit_verified else f"Circuit not verified after {current_iteration + 1} iterations"
        result["success"] = circuit_verified
        
    except Exception as e:
        print(f"ERROR in pipeline: {str(e)}")
        import traceback
        traceback.print_exc()
        result["error"] = str(e)
    
    end_time = time.time()
    elapsed_time = end_time - start_time
    
    print_separator("PIPELINE TEST COMPLETED")
    print(f"Total processing time: {elapsed_time:.2f} seconds")
    print(f"Total iterations performed: {len(result['iterations'])}")
    print(f"Final status: {result.get('final_status', 'Unknown')}")
    
    # Print summary of each iteration
    print("\nIteration Summary:")
    for i, iteration in enumerate(result.get("iterations", [])):
        is_verified = iteration.get("vision_feedback", "") == "Y"
        status = "✓ VERIFIED" if is_verified else "✗ NOT VERIFIED"
        print(f"Iteration {i}: {status}")
    
    return result

def main():
    """Main function to parse arguments and run tests"""
    parser = argparse.ArgumentParser(description='Test the iterative LTSpice Agent pipeline')
    parser.add_argument('--prompt', '-p', type=str, default="Create a low pass filter", help='Prompt to test')
    parser.add_argument('--id', type=int, default=1, help='Prompt ID for folder structure')
    parser.add_argument('--iterations', '-i', type=int, default=3, help='Maximum number of iterations')
    parser.add_argument('--verbose', '-v', action='store_true', help='Enable verbose logging')
    args = parser.parse_args()
    
    # Set logging level based on verbose flag
    if args.verbose:
        logging.getLogger('electroninja').setLevel(logging.DEBUG)
        
    # Run the test
    test_iterative_pipeline(args.prompt, prompt_id=args.id, max_iterations=args.iterations)

if __name__ == "__main__":
    main()

File: .\tests\test_ltspice_processing.py
----------------------------------------
#!/usr/bin/env python3
# tests/test_ltspice_processing.py

import os
import sys
import logging
import platform
import time
import cProfile
import pstats
import io
from dotenv import load_dotenv

# Add parent directory to path to allow imports from the project
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(project_root)

# Import from electroninja
from electroninja.config.settings import Config
from electroninja.core.ltspice.interface import LTSpiceInterface

# Load environment variables
load_dotenv()

# Set up logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def print_separator(title=None):
    """Print a formatted separator line with an optional title."""
    width = 80
    if title:
        print("\n" + "=" * 20 + f" {title} " + "=" * (width - len(title) - 22) + "\n")
    else:
        print("\n" + "=" * width + "\n")

def test_ltspice_processing(asc_code, prompt_id=1, iteration=0):
    """
    Test the LTSpice processing workflow:
      - Saves the ASC file to data/output/prompt{prompt_id}/output{iteration}/code.asc.
      - Launches LTSpice GUI, prints to PDF, and converts the PDF to a cropped square PNG.
      - Verifies that the expected files and folder structure are created.
    
    Returns:
        Tuple (asc_path, image_path) on success, or None on failure.
    """
    config = Config()
    ltspice = LTSpiceInterface(config)

    print_separator("TEST: LTSPICE PROCESSING")
    print(f"Platform: {platform.system()} {platform.release()}")
    print(f"LTSpice path: {config.LTSPICE_PATH}")
    print(f"Output directory: {config.OUTPUT_DIR}\n")

    if not os.path.exists(config.LTSPICE_PATH):
        print(f"WARNING: LTSpice not found at {config.LTSPICE_PATH}")
        print("This may cause the test to fail. Please update the path in your .env file.")

    print("ASC Code to Process:\n-------------------")
    if len(asc_code) < 1000:
        print(asc_code)
    else:
        print(asc_code[:1000] + "...")
    print("-------------------\n")

    print_separator("PROCESSING WITH LTSPICE")
    print("Starting LTSpice processing...")
    print(f"Time: {time.strftime('%H:%M:%S')}")

    result = ltspice.process_circuit(asc_code, prompt_id=prompt_id, iteration=iteration)
    finish_time = time.strftime('%H:%M:%S')
    print(f"Processing completed at: {finish_time}\n")

    if not result:
        print_separator("TEST FAILED")
        print("LTSpice processing failed: No result returned.")
        return None

    asc_path, image_path = result
    print_separator("LTSPICE PROCESSING RESULTS")
    print(f"ASC file path: {asc_path}")
    print(f"Image file path: {image_path}")

    if not os.path.exists(asc_path):
        print("Error: ASC file does not exist!")
        return None
    if not os.path.exists(image_path):
        print("Error: Image file does not exist!")
        return None

    print("Successfully processed circuit through LTSpice!\n")

    # Verify file details
    print("Verifying file details:")
    print(f"ASC file exists: {os.path.exists(asc_path)}")
    print(f"Image file exists: {os.path.exists(image_path)}")
    if os.path.exists(image_path):
        print(f"Image file size: {os.path.getsize(image_path)} bytes")

    # Verify folder structure
    output_dir = os.path.dirname(asc_path)
    print("\nVerifying folder structure:")
    print(f"Output directory exists: {os.path.exists(output_dir)}")
    print(f"ASC file named 'code.asc': {asc_path.endswith('code.asc')}")
    print(f"Image file named 'image.png': {image_path.endswith('image.png')}")

    # List files in the output directory
    print("\nListing files in output directory:")
    if os.path.exists(output_dir):
        for file in os.listdir(output_dir):
            file_path = os.path.join(output_dir, file)
            size = os.path.getsize(file_path)
            print(f"  - {file} ({size} bytes)")

    print_separator("TEST COMPLETED SUCCESSFULLY")
    return (asc_path, image_path)

def main():
    test_asc_code = """Version 4
SHEET 1 880 680
WIRE 224 80 80 80
WIRE 336 80 224 80
WIRE 80 128 80 80
WIRE 224 128 224 80
WIRE 336 128 336 80
WIRE 80 240 80 208
WIRE 224 240 224 208
WIRE 224 240 80 240
WIRE 336 240 336 208
WIRE 336 240 224 240
SYMBOL voltage 80 112 R0
SYMATTR InstName V1
SYMATTR Value 50
SYMBOL res 208 112 R0
SYMATTR InstName R1
SYMATTR Value 200
SYMBOL res 320 112 R0
SYMATTR InstName R2
SYMATTR Value 100
TEXT 136 264 Left 2 !.op
"""
    prompt_id = "1"
    iteration = "0"

    result = test_ltspice_processing(test_asc_code, prompt_id, iteration)
    if result:
        asc_path, image_path = result
        print(f"\nTest completed successfully.\nASC file: {asc_path}\nImage file: {image_path}")
    else:
        print("\nTest failed.")

if __name__ == "__main__":
    pr = cProfile.Profile()
    pr.enable()
    main()
    pr.disable()
    s = io.StringIO()
    ps = pstats.Stats(pr, stream=s).sort_stats('tottime')
    ps.print_stats(10)
    print(s.getvalue())


File: .\tests\test_vision_analysis.py
-------------------------------------
# tests/test_vision_analysis.py
import os
import sys
import logging
import argparse
from dotenv import load_dotenv

# Add parent directory to path to allow imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from electroninja.config.settings import Config
from electroninja.llm.vision_analyser import VisionAnalyzer

# Load environment variables
load_dotenv()

# Set up minimal logging
logging.basicConfig(
    level=logging.WARNING,  # Only show warnings and errors
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    filename='vision_test.log',
    filemode='w'
)

def test_vision_analysis(image_path, original_request):
    """
    Test vision analysis of circuit images and return raw output
    
    Args:
        image_path (str): Path to the circuit image
        original_request (str): Original user request
    """
    # Validate image path
    if not os.path.exists(image_path):
        print(f"ERROR: Image file not found: {image_path}")
        return
    
    try:
        # Initialize components
        config = Config()
        vision_analyzer = VisionAnalyzer(config)
        
        # Analyze the image
        analysis = vision_analyzer.analyze_circuit_image(image_path, original_request)
        
        # Print only the raw LLM output with no formatting
        print(analysis)
        
    except Exception as e:
        print(f"ERROR: {str(e)}")

def main():
    """Main function to run the test"""
    parser = argparse.ArgumentParser(description='Test vision analysis of circuit images')
    parser.add_argument('--image', '-i', type=str, help='Path to circuit image')
    parser.add_argument('--request', '-r', type=str, help='User request to test')
    args = parser.parse_args()
    
    # Use default image path if not provided
    if not args.image:
        default_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                                 "data", "output", "prompt1", "output0", "image.png")
        args.image = default_path
    
    # Use default request if not provided
    if not args.request:
        default_requests = [
            "Design a voltage divider circuit",
            "Create a circuit with two resistors in parallel",
            "Make an RC low-pass filter"
        ]
        
        for i, request in enumerate(default_requests, 1):
            if i > 1:
                print("\n----------------------------------------\n")
            test_vision_analysis(args.image, request)
    else:
        # Run single test with provided request
        test_vision_analysis(args.image, args.request)

if __name__ == "__main__":
    main()

File: .\tests\test_vision_feedback_response.py
----------------------------------------------
# tests/test_vision_feedback_response.py
import os
import sys
import logging
from dotenv import load_dotenv

# Add parent directory to path to allow imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from electroninja.config.settings import Config
from electroninja.llm.providers.openai import OpenAIProvider

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def test_vision_feedback_response(vision_feedback):
    """
    Test generating user-friendly responses from vision model feedback
    
    Args:
        vision_feedback (str): Feedback from vision model
        
    Returns:
        str: User-friendly response
    """
    # Initialize components
    config = Config()
    llm_provider = OpenAIProvider(config)
    
    print("\n====== TEST: VISION FEEDBACK RESPONSE ======\n")
    print("Vision feedback:")
    print("-" * 40)
    print(vision_feedback)
    print("-" * 40)
    
    # Generate response
    try:
        response = llm_provider.generate_vision_feedback_response(vision_feedback)
        
        print("\nGenerated response:")
        print("-" * 40)
        print(response)
        print("-" * 40)
        
        return response
        
    except Exception as e:
        print(f"Error: {str(e)}")
        return None

if __name__ == "__main__":
    # Test case 1: Successful circuit (Y)
    success_feedback = "Y"
    
    # Test case 2: Circuit with issues (detailed feedback)
    failure_feedback = """1. **Components Present**:
   - Voltage source (V1 = 50V)
   - Resistor R1 = 200 ohms
   - Resistor R2 = 100 ohms

2. **Connections**:
   - Resistors R1 and R2 are in parallel.
   - The parallel combination is connected across the voltage source.

3. **Comparison to Standard Voltage Divider**:
   - A standard voltage divider circuit consists of two resistors in series. The output voltage is taken across one of the resistors.

4. **Issues**:
   - The current configuration has R1 and R2 in parallel, not in series.

5. **Why It Doesn’t Meet the Requirements**:
   - A voltage divider relies on the series arrangement of resistors to divide the input voltage proportionally based on their resistance values (principle: \( V_out = V_in \times \frac{R2}{R1 + R2} \)).

6. **Recommendations for Fixing**:
   - Connect R1 and R2 in series.
   - Connect one terminal of R1 to the positive end of V1.
   - Connect the other terminal of R2 to the negative end (or ground) of V1.
   - Take the output voltage across R2 (or R1, depending on the desired division ratio).

7. **Expected Behavior After Modifications**:
   - The circuit will correctly divide the 50V input according to the ratio of the resistances.
   - With R1 = 200 ohms and R2 = 100 ohms, the expected output voltage across R2 will be:
     \[
     V_{out} = 50 \times \frac{100}{200 + 100} = \frac{50}{3} \approx 16.67V
     \]

By reconfiguring R1 and R2 in series, the circuit will function as a proper voltage divider."""
    
    # Run tests
    print("\n\n=== TEST 1: SUCCESSFUL CIRCUIT ===\n")
    test_vision_feedback_response(success_feedback)
    
    print("\n\n=== TEST 2: CIRCUIT WITH ISSUES ===\n")
    test_vision_feedback_response(failure_feedback)
